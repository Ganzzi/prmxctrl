# Plan: Auto-Generated Hierarchical Proxmox SDK (v7.4-2)

## Core Principles
1. **100% Auto-generated** - No manual endpoint coding
2. **Hierarchical structure** - Mirror API path structure exactly
3. **Single version focus** - Perfect v7.4-2 implementation first
4. **Type-safe everything** - Pydantic models for all params/responses
5. **Developer experience** - Intuitive autocomplete and navigation

---

## Project Architecture

### Directory Structure
```
prmxctrl/
├── generator/                      # Code generation tools (not in package)
│   ├── __init__.py
│   ├── fetch_schema.py            # Download apidata.js from GitHub
│   ├── parse_schema.py            # Parse JS → structured format
│   ├── analyze_schema.py          # Analyze and validate schema
│   ├── generators/
│   │   ├── __init__.py
│   │   ├── model_generator.py     # Generate Pydantic models
│   │   ├── endpoint_generator.py  # Generate endpoint classes
│   │   ├── client_generator.py    # Generate main client
│   │   └── utils.py               # Shared utilities
│   ├── templates/                  # Jinja2 templates
│   │   ├── model.py.jinja
│   │   ├── endpoint.py.jinja
│   │   └── client.py.jinja
│   └── config.py                   # Generation configuration
│
├── prmxctrl/                    # Generated package
│   ├── __init__.py                # Export ProxmoxClient
│   ├── client.py                  # GENERATED: Main client entry
│   ├── base/                      # Hand-written base classes
│   │   ├── __init__.py
│   │   ├── http_client.py        # HTTP/Auth implementation
│   │   ├── endpoint_base.py      # Base endpoint class
│   │   ├── types.py              # Common types
│   │   └── exceptions.py         # Custom exceptions
│   │
│   ├── models/                    # GENERATED: All Pydantic models
│   │   ├── __init__.py
│   │   ├── access.py             # /access models
│   │   ├── cluster.py            # /cluster models
│   │   ├── nodes.py              # /nodes models
│   │   ├── pools.py              # /pools models
│   │   ├── storage.py            # /storage models
│   │   └── common.py             # Shared models
│   │
│   └── endpoints/                 # GENERATED: Hierarchical endpoints
│       ├── __init__.py
│       ├── access.py              # /access endpoints
│       ├── cluster.py             # /cluster endpoints
│       ├── nodes/                 # /nodes/* nested structure
│       │   ├── __init__.py
│       │   ├── _base.py          # /nodes endpoints
│       │   ├── qemu/             # /nodes/{node}/qemu/*
│       │   │   ├── __init__.py
│       │   │   ├── _base.py      # /nodes/{node}/qemu
│       │   │   ├── _item.py      # /nodes/{node}/qemu/{vmid}
│       │   │   ├── config.py     # /nodes/{node}/qemu/{vmid}/config
│       │   │   ├── status.py     # /nodes/{node}/qemu/{vmid}/status/*
│       │   │   ├── agent.py      # /nodes/{node}/qemu/{vmid}/agent/*
│       │   │   └── migrate.py
│       │   ├── lxc/              # /nodes/{node}/lxc/*
│       │   ├── storage/          # /nodes/{node}/storage/*
│       │   └── tasks/            # /nodes/{node}/tasks/*
│       ├── pools.py
│       ├── storage.py
│       └── version.py
│
├── tools/
│   ├── generate.py                # Main CLI: python tools/generate.py
│   └── validate.py                # Validate generated code
│
├── tests/
│   ├── generator/                 # Test generation logic
│   └── integration/               # Test generated SDK
│
├── schemas/
│   └── v7.4-2.json               # Parsed schema (cached)
│
├── pyproject.toml
├── README.md
└── GENERATION.md                  # How code generation works
```

---

## Phase 1: Schema Processing (Days 1-2)

### 1.1 Fetch and Parse Schema

```python
# generator/fetch_schema.py
import httpx
import re
import json

class SchemaFetcher:
    """Fetch apidata.js from GitHub commit"""
    
    COMMIT = "f42edd7afd805a27fd7a0b027d67ca7adeedc2c6"
    URL = f"https://raw.githubusercontent.com/proxmox/pve-docs/{COMMIT}/api-viewer/apidata.js"
    
    async def fetch(self) -> str:
        """Download apidata.js"""
        async with httpx.AsyncClient() as client:
            response = await client.get(self.URL)
            return response.text
    
    def extract_schema(self, js_content: str) -> str:
        """Extract 'const apiSchema = [...]' from JS"""
        # Remove comments
        js_content = re.sub(r'//.*?\n', '\n', js_content)
        js_content = re.sub(r'/\*.*?\*/', '', js_content, flags=re.DOTALL)
        
        # Find apiSchema definition
        match = re.search(r'const\s+apiSchema\s*=\s*(\[.*?\]);', js_content, re.DOTALL)
        if not match:
            raise ValueError("Could not find apiSchema in JS file")
        
        # Clean up JavaScript-specific syntax
        json_str = match.group(1)
        json_str = re.sub(r',(\s*[}\]])', r'\1', json_str)  # Remove trailing commas
        
        return json_str
    
    def parse_to_json(self, json_str: str) -> list:
        """Parse to Python object"""
        return json.loads(json_str)
    
    async def fetch_and_parse(self, cache_file: str = "schemas/v7.4-2.json"):
        """Complete pipeline with caching"""
        if os.path.exists(cache_file):
            with open(cache_file) as f:
                return json.load(f)
        
        js_content = await self.fetch()
        json_str = self.extract_schema(js_content)
        schema = self.parse_to_json(json_str)
        
        os.makedirs(os.path.dirname(cache_file), exist_ok=True)
        with open(cache_file, 'w') as f:
            json.dump(schema, f, indent=2)
        
        return schema
```

### 1.2 Schema Analysis and Structure

```python
# generator/parse_schema.py
from dataclasses import dataclass, field
from typing import Optional, Literal

@dataclass
class Parameter:
    """API parameter definition"""
    name: str
    type: str
    description: Optional[str] = None
    optional: bool = False
    default: Optional[any] = None
    format: Optional[str] = None
    minimum: Optional[int] = None
    maximum: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None
    enum: Optional[list] = None
    properties: Optional[dict] = None  # For nested objects

@dataclass
class Response:
    """API response definition"""
    type: str
    description: Optional[str] = None
    properties: Optional[dict] = None
    items: Optional[dict] = None  # For array responses

@dataclass
class Method:
    """HTTP method definition"""
    method: Literal["GET", "POST", "PUT", "DELETE"]
    name: str
    description: Optional[str] = None
    parameters: list[Parameter] = field(default_factory=list)
    returns: Optional[Response] = None
    protected: bool = False
    proxyto: Optional[str] = None
    permissions: Optional[dict] = None

@dataclass
class Endpoint:
    """API endpoint definition"""
    path: str
    text: str  # URL segment name
    leaf: bool  # True if terminal node
    methods: dict[str, Method] = field(default_factory=dict)
    children: list['Endpoint'] = field(default_factory=list)
    
    # Parsed metadata
    path_params: list[str] = field(default_factory=list)  # e.g., ['node', 'vmid']
    python_path: str = ""  # e.g., "nodes.qemu.item"
    class_name: str = ""   # e.g., "NodesQemuItemEndpoints"

class SchemaParser:
    """Parse raw schema into structured format"""
    
    def parse(self, raw_schema: list) -> list[Endpoint]:
        """Parse schema recursively"""
        return [self._parse_node(node, parent_path="") for node in raw_schema]
    
    def _parse_node(self, node: dict, parent_path: str) -> Endpoint:
        """Parse single schema node"""
        path = node['path']
        text = node['text']
        
        endpoint = Endpoint(
            path=path,
            text=text,
            leaf=node.get('leaf', 0) == 1
        )
        
        # Extract path parameters: /nodes/{node}/qemu/{vmid}
        endpoint.path_params = re.findall(r'\{(\w+)\}', path)
        
        # Parse methods (GET, POST, PUT, DELETE)
        if 'info' in node:
            for method_name, method_info in node['info'].items():
                endpoint.methods[method_name] = self._parse_method(method_name, method_info)
        
        # Parse children recursively
        if 'children' in node:
            endpoint.children = [
                self._parse_node(child, path) 
                for child in node['children']
            ]
        
        # Generate Python naming
        endpoint.python_path = self._generate_python_path(path)
        endpoint.class_name = self._generate_class_name(path)
        
        return endpoint
    
    def _parse_method(self, method_name: str, method_info: dict) -> Method:
        """Parse method definition"""
        method = Method(
            method=method_name,
            name=method_info.get('name', ''),
            description=method_info.get('description'),
            protected=method_info.get('protected', 0) == 1
        )
        
        # Parse parameters
        if 'parameters' in method_info:
            params_info = method_info['parameters']
            if 'properties' in params_info:
                method.parameters = [
                    self._parse_parameter(name, prop)
                    for name, prop in params_info['properties'].items()
                ]
        
        # Parse response
        if 'returns' in method_info:
            method.returns = self._parse_response(method_info['returns'])
        
        return method
    
    def _parse_parameter(self, name: str, prop: dict) -> Parameter:
        """Parse parameter definition"""
        return Parameter(
            name=name,
            type=prop.get('type', 'string'),
            description=prop.get('description'),
            optional=prop.get('optional', 0) == 1,
            default=prop.get('default'),
            format=prop.get('format'),
            minimum=prop.get('minimum'),
            maximum=prop.get('maximum'),
            max_length=prop.get('maxLength'),
            pattern=prop.get('pattern'),
            enum=prop.get('enum'),
            properties=prop.get('properties') or prop.get('format')  # Nested properties
        )
    
    def _generate_python_path(self, api_path: str) -> str:
        """
        Convert API path to Python attribute path
        /nodes/{node}/qemu/{vmid}/config → nodes.qemu(node).item(vmid).config
        """
        # This is simplified; actual implementation needs more logic
        parts = api_path.strip('/').split('/')
        python_parts = []
        
        for part in parts:
            if '{' in part:
                param = part.strip('{}')
                python_parts.append(f'item_{param}')
            else:
                python_parts.append(part)
        
        return '.'.join(python_parts)
    
    def _generate_class_name(self, api_path: str) -> str:
        """
        Generate class name from path
        /nodes/{node}/qemu/{vmid} → NodesQemuItemEndpoints
        """
        parts = api_path.strip('/').split('/')
        name_parts = []
        
        for part in parts:
            if '{' in part:
                name_parts.append('Item')
            else:
                name_parts.append(part.capitalize())
        
        return ''.join(name_parts) + 'Endpoints'
```

### 1.3 Schema Analyzer

```python
# generator/analyze_schema.py
class SchemaAnalyzer:
    """Analyze parsed schema to generate metadata for code generation"""
    
    def analyze(self, endpoints: list[Endpoint]) -> dict:
        """Generate complete analysis"""
        return {
            'total_endpoints': self._count_endpoints(endpoints),
            'total_methods': self._count_methods(endpoints),
            'path_tree': self._build_tree(endpoints),
            'all_endpoints': self._flatten_endpoints(endpoints),
            'parameter_types': self._collect_parameter_types(endpoints),
            'common_models': self._identify_common_models(endpoints),
        }
    
    def _build_tree(self, endpoints: list[Endpoint]) -> dict:
        """Build hierarchical tree structure for navigation"""
        tree = {}
        for endpoint in endpoints:
            self._add_to_tree(tree, endpoint)
        return tree
    
    def _identify_common_models(self, endpoints: list[Endpoint]) -> list:
        """Identify parameters/responses used across multiple endpoints"""
        # Find patterns like 'node', 'vmid', common config objects
        # These become shared models in models/common.py
        pass
```

---

## Phase 2: Model Generation (Days 3-4)

### 2.1 Type Mapping System

```python
# generator/generators/model_generator.py
class TypeMapper:
    """Map Proxmox types to Python/Pydantic types"""
    
    BASE_TYPES = {
        'string': 'str',
        'integer': 'int',
        'number': 'float',
        'boolean': 'bool',
        'array': 'list',
        'object': 'dict',
    }
    
    FORMAT_TYPES = {
        'pve-node': 'str',  # Could create custom types later
        'pve-vmid': 'int',
        'address': 'str',
        'dns-name': 'str',
        'email': 'EmailStr',  # Use Pydantic's EmailStr
        'uuid': 'str',
    }
    
    def map_parameter(self, param: Parameter) -> str:
        """Generate Pydantic field type with constraints"""
        base_type = self._get_base_type(param)
        constraints = self._get_constraints(param)
        
        # Build type annotation
        if param.optional:
            type_str = f"Optional[{base_type}]"
        else:
            type_str = base_type
        
        return type_str, constraints
    
    def _get_base_type(self, param: Parameter) -> str:
        """Determine base Python type"""
        if param.enum:
            # Generate Literal type
            values = ', '.join(f'"{v}"' for v in param.enum)
            return f'Literal[{values}]'
        
        if param.format and param.format in self.FORMAT_TYPES:
            return self.FORMAT_TYPES[param.format]
        
        return self.BASE_TYPES.get(param.type, 'Any')
    
    def _get_constraints(self, param: Parameter) -> dict:
        """Generate Pydantic Field constraints"""
        constraints = {}
        
        if param.minimum is not None:
            constraints['ge'] = param.minimum
        if param.maximum is not None:
            constraints['le'] = param.maximum
        if param.max_length is not None:
            constraints['max_length'] = param.max_length
        if param.pattern:
            constraints['pattern'] = param.pattern
        if param.description:
            constraints['description'] = param.description
        if param.default is not None:
            constraints['default'] = param.default
        
        return constraints
```

### 2.2 Model Generator

```python
# generator/generators/model_generator.py
from jinja2 import Environment, FileSystemLoader

class ModelGenerator:
    """Generate Pydantic models from endpoints"""
    
    def __init__(self):
        self.type_mapper = TypeMapper()
        self.env = Environment(loader=FileSystemLoader('generator/templates'))
    
    def generate_models_file(self, endpoints: list[Endpoint], module_name: str) -> str:
        """
        Generate complete models file for a module (e.g., nodes.py)
        Contains all request/response models for that module
        """
        models = []
        
        for endpoint in endpoints:
            for method in endpoint.methods.values():
                # Generate request model
                if method.parameters:
                    models.append(self._generate_request_model(endpoint, method))
                
                # Generate response model
                if method.returns:
                    models.append(self._generate_response_model(endpoint, method))
        
        template = self.env.get_template('model.py.jinja')
        return template.render(
            module_name=module_name,
            models=models,
            imports=self._collect_imports(models)
        )
    
    def _generate_request_model(self, endpoint: Endpoint, method: Method) -> dict:
        """Generate request parameters model"""
        # Model name: NodesQemuCreateParams
        model_name = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Params"
        
        fields = []
        for param in method.parameters:
            type_str, constraints = self.type_mapper.map_parameter(param)
            
            # Handle nested objects (like link[n] in your example)
            if param.properties:
                # Create nested model
                nested_model = self._generate_nested_model(param)
                type_str = nested_model['name']
            
            field_def = {
                'name': param.name,
                'type': type_str,
                'constraints': constraints,
                'optional': param.optional
            }
            fields.append(field_def)
        
        return {
            'name': model_name,
            'type': 'request',
            'fields': fields,
            'docstring': method.description
        }
    
    def _generate_response_model(self, endpoint: Endpoint, method: Method) -> dict:
        """Generate response model"""
        model_name = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Response"
        
        if not method.returns:
            return None
        
        # Handle different response types
        if method.returns.type == 'array':
            # List response
            item_type = self._parse_response_item(method.returns.items)
            return {
                'name': model_name,
                'type': 'response',
                'is_list': True,
                'item_type': item_type
            }
        elif method.returns.type == 'object':
            # Object response
            fields = self._parse_response_properties(method.returns.properties)
            return {
                'name': model_name,
                'type': 'response',
                'fields': fields
            }
        else:
            # Simple type response
            return {
                'name': model_name,
                'type': 'response',
                'simple_type': self.type_mapper.BASE_TYPES.get(method.returns.type, 'Any')
            }
```

### 2.3 Model Template

```jinja2
{# generator/templates/model.py.jinja #}
"""
Generated Pydantic models for {{ module_name }}
Auto-generated from Proxmox VE API schema v7.4-2
DO NOT EDIT MANUALLY
"""

from typing import Optional, Literal, Any
from pydantic import BaseModel, Field, conint, constr
{% for import in imports %}
{{ import }}
{% endfor %}

{% for model in models %}
class {{ model.name }}(BaseModel):
    """{{ model.docstring or 'Auto-generated model' }}"""
    
    {% if model.type == 'request' or (model.type == 'response' and model.fields) %}
    {% for field in model.fields %}
    {{ field.name }}: {{ field.type }}{% if field.constraints %} = Field(
        {% if not field.optional and 'default' not in field.constraints %}...{% endif %}
        {% for key, value in field.constraints.items() %}
        {% if key == 'description' %}
        {{ key }}="{{ value }}"
        {% else %}
        {{ key }}={{ value }}
        {% endif %}
        {% if not loop.last %},{% endif %}
        {% endfor %}
    ){% elif field.optional %} = None{% endif %}
    {% endfor %}
    {% elif model.is_list %}
    __root__: list[{{ model.item_type }}]
    {% else %}
    __root__: {{ model.simple_type }}
    {% endif %}
    
    class Config:
        extra = 'forbid'  # Strict validation

{% endfor %}
```

---

## Phase 3: Endpoint Generation (Days 5-7)

### 3.1 Hierarchical Endpoint Structure

The key insight: **Mirror the API path structure in Python classes with method chaining**

```python
# Example of desired usage:
async with ProxmoxClient(...) as client:
    # GET /nodes/{node}/qemu
    vms = await client.nodes("pve1").qemu.list()
    
    # GET /nodes/{node}/qemu/{vmid}/config
    config = await client.nodes("pve1").qemu(100).config.get()
    
    # POST /nodes/{node}/qemu/{vmid}/status/start
    await client.nodes("pve1").qemu(100).status.start()
    
    # POST /nodes/{node}/qemu/{vmid}/agent/exec
    result = await client.nodes("pve1").qemu(100).agent.exec(command="ls")
```

### 3.2 Endpoint Base Class

```python
# prmxctrl/base/endpoint_base.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from prmxctrl.base.http_client import HTTPClient

class EndpointBase:
    """Base class for all endpoint classes"""
    
    def __init__(self, client: 'HTTPClient', path: str = ""):
        self._client = client
        self._path = path
    
    def _build_path(self, *parts) -> str:
        """Build full API path"""
        all_parts = [self._path] + [str(p) for p in parts if p]
        return '/' + '/'.join(p.strip('/') for p in all_parts if p)
    
    async def _get(self, path: str, params: dict = None):
        """GET request helper"""
        return await self._client.get(self._build_path(path), params=params)
    
    async def _post(self, path: str, data: dict = None):
        """POST request helper"""
        return await self._client.post(self._build_path(path), data=data)
    
    async def _put(self, path: str, data: dict = None):
        """PUT request helper"""
        return await self._client.put(self._build_path(path), data=data)
    
    async def _delete(self, path: str):
        """DELETE request helper"""
        return await self._client.delete(self._build_path(path))
```

### 3.3 Endpoint Generator

```python
# generator/generators/endpoint_generator.py
class EndpointGenerator:
    """Generate endpoint classes with hierarchical structure"""
    
    def generate_endpoint_file(self, endpoint: Endpoint, children: list[Endpoint]) -> str:
        """
        Generate endpoint file with class and sub-endpoints
        
        For /nodes/{node}/qemu, generates:
        - NodesQemuEndpoints class with list() method
        - __call__ method returning NodesQemuItemEndpoints
        - Properties for sub-endpoints (config, status, agent, etc.)
        """
        
        # Determine file structure
        has_methods = len(endpoint.methods) > 0
        has_children = len(children) > 0
        has_path_params = len(endpoint.path_params) > 0
        
        classes = []
        
        # Generate main endpoint class
        if has_methods or has_children:
            classes.append(self._generate_endpoint_class(endpoint, children))
        
        # Generate item class if has path parameters
        if has_path_params and children:
            classes.append(self._generate_item_class(endpoint, children))
        
        template = self.env.get_template('endpoint.py.jinja')
        return template.render(
            endpoint=endpoint,
            classes=classes,
            imports=self._collect_imports(endpoint, children)
        )
    
    def _generate_endpoint_class(self, endpoint: Endpoint, children: list[Endpoint]) -> dict:
        """
        Generate main endpoint class
        Example: NodesQemuEndpoints
        """
        class_info = {
            'name': endpoint.class_name,
            'methods': [],
            'properties': [],
            'callable': len(endpoint.path_params) > 0
        }
        
        # Generate API methods (GET, POST, etc.)
        for method in endpoint.methods.values():
            class_info['methods'].append(self._generate_method(endpoint, method))
        
        # Generate properties for child endpoints
        for child in children:
            if not child.path_params:  # Only direct children, not parameterized
                class_info['properties'].append({
                    'name': child.text,
                    'class': child.class_name,
                    'path': child.text
                })
        
        # Generate __call__ if this endpoint has path parameters
        if endpoint.path_params:
            class_info['call_method'] = self._generate_call_method(endpoint)
        
        return class_info
    
    def _generate_method(self, endpoint: Endpoint, method: Method) -> dict:
        """
        Generate a single API method
        
        Example:
        async def list(self, params: NodesQemuListParams = None) -> NodesQemuListResponse:
            ...
        """
        method_name = self._get_method_name(method)
        
        # Determine parameter model
        param_model = None
        if method.parameters:
            param_model = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Params"
        
        # Determine response model
        response_model = None
        if method.returns:
            response_model = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Response"
        
        return {
            'name': method_name,
            'http_method': method.method,
            'param_model': param_model,
            'response_model': response_model,
            'description': method.description,
            'path': '',  # Use current path
        }
    
    def _get_method_name(self, method: Method) -> str:
        """
        Convert method info to Python method name
        GET -> get() or list()
        POST -> create() or action name
        PUT -> update()
        DELETE -> delete()
        """
        if method.method == 'GET':
            # If returns array, call it list(), otherwise get()
            if method.returns and method.returns.type == 'array':
                return 'list'
            return 'get'
        elif method.method == 'POST':
            # Use the method name from schema
            return method.name or 'create'
        elif method.method == 'PUT':
            return method.name or 'update'
        elif method.method == 'DELETE':
            return 'delete'
    
    def _generate_call_method(self, endpoint: Endpoint) -> dict:
        """
        Generate __call__ method for parameterized access
        
        Example:
        def __call__(self, vmid: int) -> NodesQemuItemEndpoints:
            return NodesQemuItemEndpoints(self._client, self._path, vmid)
        """
        param_name = endpoint.path_params[0]  # Assume single param for now
        item_class = endpoint.class_name.replace('Endpoints', 'ItemEndpoints')
        
        return {
            'param_name': param_name,
            'param_type': 'int' if 'id' in param_name else 'str',
            'item_class': item_class
        }
    
    def _generate_item_class(self, endpoint: Endpoint, children: list[Endpoint]) -> dict:
        """
        Generate item class for parameterized endpoints
        Example: NodesQemuItemEndpoints (for specific vmid)
        """
        item_class = endpoint.class_name.replace('Endpoints', 'ItemEndpoints')
        param_name = endpoint.path_params[0]
        
        class_info = {
            'name': item_class,
            'param_name': param_name,
            'param_type': 'int' if 'id' in param_name else 'str',
            'methods': [],
            'properties': []
        }
        
        # Methods that operate on the item
        for child in children:
            if child.methods:
                # This child has methods, make it a property
                class_info['properties'].append({
                    'name': child.text,
                    'class': child.class_name,
                    'path': child.text
                })
        
        return class_info
```

### 3.4 Endpoint Template

```jinja2
{# generator/templates/endpoint.py.jinja #}
"""
Generated endpoint classes for {{ endpoint.path }}
Auto-generated from Proxmox VE API schema v7.4-2
DO NOT EDIT MANUALLY
"""

from typing import Optional
from prmxctrl.base.endpoint_base import EndpointBase
{% for import in imports %}
{{ import }}
{% endfor %}

{% for class in classes %}
class {{ class.name }}(EndpointBase):
    """Endpoint class for {{ endpoint.path }}"""
    
    {% if class.properties %}
    # Sub-endpoint properties
    {% for prop in class.properties %}
    @property
    def {{ prop.name }}(self) -> '{{ prop.class }}':
        """Access {{ prop.path }} endpoints"""
        from .{{ prop.name }} import {{ prop.class }}
        return {{ prop.class }}(self._client, self._build_path("{{ prop.path }}"))
    
    {% endfor %}
    {% endif %}
    
    {% if class.callable %}
    def __call__(self, {{ class.call_method.param_name }}: {{ class.call_method.param_type }}) -> '{{ class.call_method.item_class }}':
        """Access specific {{ class.call_method.param_name }}"""
        return {{ class.call_method.item_class }}(
            self._client, 
            self._build_path(str({{ class.call_method.param_name }}))
        )
    
    {% endif %}

    {% for method in class.methods %}
    async def {{ method.name }}(
        self
        {%- if method.param_model -%}
        , params: Optional['{{ method.param_model }}'] = None
        {%- endif -%}
    ) -> {% if method.response_model %}'{{ method.response_model }}'{% else %}dict{% endif %}:
        """
        {{ method.description or 'API method' }}
        
        {% if method.http_method == 'GET' %}
        HTTP Method: GET
        {% elif method.http_method == 'POST' %}
        HTTP Method: POST
        {% elif method.http_method == 'PUT' %}
        HTTP Method: PUT
        {% elif method.http_method == 'DELETE' %}
        HTTP Method: DELETE
        {% endif %}
        """
        {% if method.http_method == 'GET' %}
        response = await self._get(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , params=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'POST' %}
        response = await self._post(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , data=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'PUT' %}
        response = await self._put(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , data=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'DELETE' %}
        response = await self._delete("{{ method.path }}")
        {% endif %}
        
        {% if method.response_model %}
        return {{ method.response_model }}(**response)
        {% else %}
        return response
        {% endif %}
    
    {% endfor %}

{% endfor %}
```

---

## Phase 4: Client Generation (Days 8-9)

### 4.1 HTTP Client Base

```python
# prmxctrl/base/http_client.py
import httpx
from typing import Optional, Any
from urllib.parse import urljoin
import json

from .exceptions import (
    ProxmoxAuthError,
    ProxmoxAPIError,
    ProxmoxConnectionError,
    ProxmoxTimeoutError
)

class HTTPClient:
    """Base HTTP client for Proxmox API"""
    
    def __init__(
        self,
        host: str,
        user: str,
        password: Optional[str] = None,
        token_name: Optional[str] = None,
        token_value: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: int = 30,
    ):
        """
        Initialize HTTP client
        
        Args:
            host: Proxmox host (e.g., https://proxmox.example.com:8006)
            user: Username (e.g., root@pam)
            password: Password for ticket-based auth
            token_name: API token name for token-based auth
            token_value: API token value for token-based auth
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        self.host = host.rstrip('/')
        self.user = user
        self.password = password
        self.token_name = token_name
        self.token_value = token_value
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        
        self._client: Optional[httpx.AsyncClient] = None
        self._ticket: Optional[str] = None
        self._csrf_token: Optional[str] = None
    
    async def __aenter__(self):
        """Async context manager entry"""
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()
    
    async def connect(self):
        """Initialize HTTP client and authenticate"""
        self._client = httpx.AsyncClient(
            verify=self.verify_ssl,
            timeout=self.timeout,
            follow_redirects=True
        )
        
        # Authenticate
        if self.token_name and self.token_value:
            # Token-based authentication
            await self._authenticate_token()
        elif self.password:
            # Ticket-based authentication
            await self._authenticate_ticket()
        else:
            raise ProxmoxAuthError("Either password or token credentials required")
    
    async def close(self):
        """Close HTTP client"""
        if self._client:
            await self._client.aclose()
            self._client = None
    
    async def _authenticate_ticket(self):
        """Authenticate with username/password to get ticket"""
        url = self._build_url('/api2/json/access/ticket')
        
        try:
            response = await self._client.post(
                url,
                data={
                    'username': self.user,
                    'password': self.password
                }
            )
            response.raise_for_status()
            
            data = response.json()['data']
            self._ticket = data['ticket']
            self._csrf_token = data['CSRFPreventionToken']
            
        except httpx.HTTPStatusError as e:
            raise ProxmoxAuthError(f"Authentication failed: {e}")
        except Exception as e:
            raise ProxmoxConnectionError(f"Connection failed: {e}")
    
    async def _authenticate_token(self):
        """Set up token-based authentication headers"""
        # Token auth doesn't require initial request
        # Headers are set in each request
        pass
    
    def _build_url(self, path: str) -> str:
        """Build full URL from path"""
        return urljoin(f"{self.host}/api2/json", path.lstrip('/'))
    
    def _get_headers(self) -> dict:
        """Get authentication headers"""
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        
        if self.token_name and self.token_value:
            # Token authentication
            headers['Authorization'] = f'PVEAPIToken={self.user}!{self.token_name}={self.token_value}'
        elif self._csrf_token:
            # Ticket authentication
            headers['CSRFPreventionToken'] = self._csrf_token
        
        return headers
    
    def _get_cookies(self) -> dict:
        """Get authentication cookies"""
        if self._ticket:
            return {'PVEAuthCookie': self._ticket}
        return {}
    
    async def request(
        self,
        method: str,
        path: str,
        params: Optional[dict] = None,
        data: Optional[dict] = None
    ) -> Any:
        """
        Make authenticated API request
        
        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            path: API path (e.g., /nodes/pve1/qemu)
            params: Query parameters (for GET)
            data: Request body (for POST/PUT)
        
        Returns:
            Parsed JSON response
        
        Raises:
            ProxmoxAPIError: API returned error
            ProxmoxTimeoutError: Request timeout
            ProxmoxConnectionError: Connection failed
        """
        if not self._client:
            raise ProxmoxConnectionError("Client not connected. Use async with or call connect()")
        
        url = self._build_url(path)
        headers = self._get_headers()
        cookies = self._get_cookies()
        
        try:
            response = await self._client.request(
                method=method,
                url=url,
                params=params,
                json=data,
                headers=headers,
                cookies=cookies
            )
            
            # Check for errors
            response.raise_for_status()
            
            # Parse response
            result = response.json()
            
            # Proxmox wraps response in 'data' key
            if isinstance(result, dict) and 'data' in result:
                return result['data']
            
            return result
            
        except httpx.TimeoutException as e:
            raise ProxmoxTimeoutError(f"Request timeout: {e}")
        except httpx.HTTPStatusError as e:
            # Try to extract error message from response
            try:
                error_data = e.response.json()
                error_msg = error_data.get('errors', str(e))
            except:
                error_msg = str(e)
            
            raise ProxmoxAPIError(
                f"API error {e.response.status_code}: {error_msg}",
                status_code=e.response.status_code
            )
        except Exception as e:
            raise ProxmoxConnectionError(f"Request failed: {e}")
    
    async def get(self, path: str, params: Optional[dict] = None) -> Any:
        """GET request"""
        return await self.request('GET', path, params=params)
    
    async def post(self, path: str, data: Optional[dict] = None) -> Any:
        """POST request"""
        return await self.request('POST', path, data=data)
    
    async def put(self, path: str, data: Optional[dict] = None) -> Any:
        """PUT request"""
        return await self.request('PUT', path, data=data)
    
    async def delete(self, path: str) -> Any:
        """DELETE request"""
        return await self.request('DELETE', path)
```

### 4.2 Custom Exceptions

```python
# prmxctrl/base/exceptions.py

class ProxmoxError(Exception):
    """Base exception for Proxmox SDK"""
    pass

class ProxmoxAuthError(ProxmoxError):
    """Authentication failed"""
    pass

class ProxmoxConnectionError(ProxmoxError):
    """Connection to Proxmox failed"""
    pass

class ProxmoxTimeoutError(ProxmoxError):
    """Request timeout"""
    pass

class ProxmoxAPIError(ProxmoxError):
    """API returned an error"""
    
    def __init__(self, message: str, status_code: Optional[int] = None):
        super().__init__(message)
        self.status_code = status_code
```

### 4.3 Main Client Generator

```python
# generator/generators/client_generator.py
class ClientGenerator:
    """Generate main ProxmoxClient class"""
    
    def generate(self, root_endpoints: list[Endpoint]) -> str:
        """
        Generate main client with all top-level endpoints as properties
        
        Example:
        class ProxmoxClient(HTTPClient):
            @property
            def access(self) -> AccessEndpoints: ...
            
            @property
            def cluster(self) -> ClusterEndpoints: ...
            
            @property
            def nodes(self) -> NodesEndpoints: ...
            
            ...
        """
        
        # Get all top-level endpoints
        top_level = []
        for endpoint in root_endpoints:
            top_level.append({
                'name': endpoint.text,
                'class': endpoint.class_name,
                'module': endpoint.text,
                'description': self._get_description(endpoint)
            })
        
        template = self.env.get_template('client.py.jinja')
        return template.render(
            endpoints=top_level,
            version='7.4-2'
        )
    
    def _get_description(self, endpoint: Endpoint) -> str:
        """Extract description from endpoint"""
        # Try to get description from GET method
        if 'GET' in endpoint.methods:
            return endpoint.methods['GET'].description or f'{endpoint.text} endpoints'
        return f'{endpoint.text} endpoints'
```

### 4.4 Client Template

```jinja2
{# generator/templates/client.py.jinja #}
"""
Proxmox VE API Client v{{ version }}
Auto-generated from Proxmox VE API schema
DO NOT EDIT MANUALLY
"""

from typing import Optional
from prmxctrl.base.http_client import HTTPClient
{% for endpoint in endpoints %}
from prmxctrl.endpoints.{{ endpoint.module }} import {{ endpoint.class }}
{% endfor %}

class ProxmoxClient(HTTPClient):
    """
    Main Proxmox VE API Client
    
    This client provides type-safe access to all Proxmox VE API endpoints.
    All endpoints are auto-generated from the official API schema.
    
    Example:
        async with ProxmoxClient(
            host='https://proxmox.example.com:8006',
            user='root@pam',
            password='secret',
            verify_ssl=False
        ) as client:
            # List all nodes
            nodes = await client.nodes.list()
            
            # Get VM config
            config = await client.nodes('pve1').qemu(100).config.get()
            
            # Start VM
            await client.nodes('pve1').qemu(100).status.start()
    """
    
    def __init__(
        self,
        host: str,
        user: str,
        password: Optional[str] = None,
        token_name: Optional[str] = None,
        token_value: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: int = 30,
    ):
        """
        Initialize Proxmox client
        
        Args:
            host: Proxmox host URL (e.g., https://proxmox.example.com:8006)
            user: Username (e.g., root@pam)
            password: Password for ticket auth
            token_name: API token name for token auth
            token_value: API token value for token auth
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        super().__init__(
            host=host,
            user=user,
            password=password,
            token_name=token_name,
            token_value=token_value,
            verify_ssl=verify_ssl,
            timeout=timeout
        )
    
    {% for endpoint in endpoints %}
    @property
    def {{ endpoint.name }}(self) -> {{ endpoint.class }}:
        """{{ endpoint.description }}"""
        return {{ endpoint.class }}(self, "/{{ endpoint.name }}")
    
    {% endfor %}
    
    async def get_version(self) -> dict:
        """Get Proxmox VE version"""
        return await self.get('/version')
```

---

## Phase 5: Generation Pipeline (Days 10-11)

### 5.1 Main Generation Script

```python
# tools/generate.py
import asyncio
import sys
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from generator.fetch_schema import SchemaFetcher
from generator.parse_schema import SchemaParser
from generator.analyze_schema import SchemaAnalyzer
from generator.generators.model_generator import ModelGenerator
from generator.generators.endpoint_generator import EndpointGenerator
from generator.generators.client_generator import ClientGenerator

app = typer.Typer()
console = Console()

class SDKGenerator:
    """Complete SDK generation pipeline"""
    
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.fetcher = SchemaFetcher()
        self.parser = SchemaParser()
        self.analyzer = SchemaAnalyzer()
        self.model_gen = ModelGenerator()
        self.endpoint_gen = EndpointGenerator()
        self.client_gen = ClientGenerator()
    
    async def generate(self):
        """Run complete generation pipeline"""
        
        console.print("[bold blue]Starting SDK generation for Proxmox VE 7.4-2[/bold blue]")
        
        # Step 1: Fetch schema
        console.print("\n[yellow]Step 1:[/yellow] Fetching API schema from GitHub...")
        raw_schema = await self.fetcher.fetch_and_parse()
        console.print(f"[green]✓[/green] Fetched {len(raw_schema)} top-level endpoints")
        
        # Step 2: Parse schema
        console.print("\n[yellow]Step 2:[/yellow] Parsing schema...")
        endpoints = self.parser.parse(raw_schema)
        console.print(f"[green]✓[/green] Parsed schema structure")
        
        # Step 3: Analyze schema
        console.print("\n[yellow]Step 3:[/yellow] Analyzing schema...")
        analysis = self.analyzer.analyze(endpoints)
        console.print(f"[green]✓[/green] Found {analysis['total_endpoints']} endpoints")
        console.print(f"[green]✓[/green] Found {analysis['total_methods']} methods")
        
        # Step 4: Generate models
        console.print("\n[yellow]Step 4:[/yellow] Generating Pydantic models...")
        await self._generate_models(endpoints)
        console.print(f"[green]✓[/green] Generated model files")
        
        # Step 5: Generate endpoints
        console.print("\n[yellow]Step 5:[/yellow] Generating endpoint classes...")
        await self._generate_endpoints(endpoints)
        console.print(f"[green]✓[/green] Generated endpoint files")
        
        # Step 6: Generate main client
        console.print("\n[yellow]Step 6:[/yellow] Generating main client...")
        await self._generate_client(endpoints)
        console.print(f"[green]✓[/green] Generated ProxmoxClient")
        
        # Step 7: Format code
        console.print("\n[yellow]Step 7:[/yellow] Formatting generated code...")
        await self._format_code()
        console.print(f"[green]✓[/green] Formatted with black")
        
        console.print("\n[bold green]✨ SDK generation complete![/bold green]")
    
    async def _generate_models(self, endpoints: list):
        """Generate all model files"""
        models_dir = self.output_dir / 'models'
        models_dir.mkdir(parents=True, exist_ok=True)
        
        # Group endpoints by top-level module
        modules = {}
        for endpoint in endpoints:
            module_name = endpoint.text
            if module_name not in modules:
                modules[module_name] = []
            
            # Collect all endpoints in this module recursively
            self._collect_endpoints(endpoint, modules[module_name])
        
        # Generate model file for each module
        for module_name, module_endpoints in modules.items():
            code = self.model_gen.generate_models_file(module_endpoints, module_name)
            
            output_file = models_dir / f'{module_name}.py'
            output_file.write_text(code)
        
        # Generate __init__.py
        init_file = models_dir / '__init__.py'
        init_code = '"""Generated Pydantic models"""\n'
        init_file.write_text(init_code)
    
    async def _generate_endpoints(self, endpoints: list):
        """Generate all endpoint files"""
        endpoints_dir = self.output_dir / 'endpoints'
        endpoints_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate endpoints recursively
        for endpoint in endpoints:
            await self._generate_endpoint_tree(endpoint, endpoints_dir)
        
        # Generate __init__.py
        init_file = endpoints_dir / '__init__.py'
        init_code = '"""Generated endpoint classes"""\n'
        init_file.write_text(init_code)
    
    async def _generate_endpoint_tree(self, endpoint, parent_dir: Path):
        """
        Generate endpoint file/directory structure recursively
        
        For /nodes, creates:
        - endpoints/nodes/__init__.py (NodesEndpoints)
        - endpoints/nodes/_base.py (node-level methods)
        - endpoints/nodes/qemu/ (subdirectory for qemu endpoints)
        """
        
        # Determine if this needs a directory or just a file
        has_children = len(endpoint.children) > 0
        has_nested_children = any(len(child.children) > 0 for child in endpoint.children)
        
        if has_nested_children:
            # Create directory for this endpoint
            endpoint_dir = parent_dir / endpoint.text
            endpoint_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate main file
            code = self.endpoint_gen.generate_endpoint_file(endpoint, endpoint.children)
            output_file = endpoint_dir / '__init__.py'
            output_file.write_text(code)
            
            # Generate children recursively
            for child in endpoint.children:
                await self._generate_endpoint_tree(child, endpoint_dir)
        else:
            # Simple endpoint, single file
            code = self.endpoint_gen.generate_endpoint_file(endpoint, endpoint.children)
            output_file = parent_dir / f'{endpoint.text}.py'
            output_file.write_text(code)
    
    async def _generate_client(self, endpoints: list):
        """Generate main client file"""
        code = self.client_gen.generate(endpoints)
        
        output_file = self.output_dir / 'client.py'
        output_file.write_text(code)
        
        # Also update __init__.py
        init_file = self.output_dir / '__init__.py'
        init_code = '''"""
Proxmox VE Python SDK
Auto-generated type-safe client for Proxmox VE API v7.4-2
"""

from prmxctrl.client import ProxmoxClient

__version__ = "0.1.0"
__all__ = ["ProxmoxClient"]
'''
        init_file.write_text(init_code)
    
    async def _format_code(self):
        """Format generated code with black"""
        import subprocess
        
        try:
            subprocess.run(
                ['black', str(self.output_dir)],
                check=True,
                capture_output=True
            )
        except subprocess.CalledProcessError as e:
            console.print(f"[yellow]Warning: black formatting failed: {e}[/yellow]")
        except FileNotFoundError:
            console.print("[yellow]Warning: black not found, skipping formatting[/yellow]")
    
    def _collect_endpoints(self, endpoint, collection: list):
        """Recursively collect all endpoints"""
        collection.append(endpoint)
        for child in endpoint.children:
            self._collect_endpoints(child, collection)

@app.command()
def generate(
    output_dir: Path = typer.Option(
        Path("prmxctrl"),
        "--output",
        "-o",
        help="Output directory for generated SDK"
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force regeneration even if output exists"
    )
):
    """Generate Proxmox VE SDK from API schema"""
    
    if output_dir.exists() and not force:
        console.print(f"[red]Error:[/red] Output directory {output_dir} already exists")
        console.print("Use --force to regenerate")
        raise typer.Exit(1)
    
    generator = SDKGenerator(output_dir)
    asyncio.run(generator.generate())

if __name__ == "__main__":
    app()
```

### 5.2 Usage

```bash
# Generate complete SDK
python tools/generate.py

# Regenerate (overwrite existing)
python tools/generate.py --force

# Custom output directory
python tools/generate.py --output my_sdk
```

---

## Phase 6: Testing & Validation (Days 12-14)

### 6.1 Test Structure

```python
# tests/conftest.py
import pytest
import os
from prmxctrl import ProxmoxClient

@pytest.fixture
def proxmox_host():
    return os.getenv('PROXMOX_HOST', 'https://proxmox.test:8006')

@pytest.fixture
def proxmox_user():
    return os.getenv('PROXMOX_USER', 'root@pam')

@pytest.fixture
def proxmox_password():
    return os.getenv('PROXMOX_PASSWORD', 'test')

@pytest.fixture
async def client(proxmox_host, proxmox_user, proxmox_password):
    """Provide authenticated client"""
    async with ProxmoxClient(
        host=proxmox_host,
        user=proxmox_user,
        password=proxmox_password,
        verify_ssl=False
    ) as client:
        yield client
```

```python
# tests/test_client.py
import pytest

@pytest.mark.asyncio
async def test_client_connection(client):
    """Test basic client connection"""
    version = await client.get_version()
    assert 'version' in version

@pytest.mark.asyncio
async def test_cluster_status(client):
    """Test cluster status retrieval"""
    status = await client.cluster.status.get()
    assert isinstance(status, list)

@pytest.mark.asyncio
async def test_nodes_list(client):
    """Test listing nodes"""
    nodes = await client.nodes.list()
    assert isinstance(nodes, list)
    assert len(nodes) > 0

@pytest.mark.asyncio
async def test_node_status(client):
    """Test node status"""
    nodes = await client.nodes.list()
    node_name = nodes[0]['node']
    
    status = await client.nodes(node_name).status.get()
    assert 'uptime' in status

@pytest.mark.asyncio
async def test_qemu_list(client):
    """Test listing VMs"""
    nodes = await client.nodes.list()
    node_name = nodes[0]['node']
    
    vms = await client.nodes(node_name).qemu.list()
    assert isinstance(vms, list)

@pytest.mark.asyncio
async def test_type_validation(client):
    """Test Pydantic validation"""
    from prmxctrl.models.cluster import ClusterConfigCreateParams
    from pydantic import ValidationError
    
    # Valid params
    params = ClusterConfigCreateParams(clustername="test-cluster")
    assert params.clustername == "test-cluster"
    
    # Invalid params (name too long)
    with pytest.raises(ValidationError):
        ClusterConfigCreateParams(clustername="a" * 20)
```

---

## Phase 7: Documentation (Days 14-15)

### 7.1 README.md

```markdown
# Proxmox VE Python SDK

Type-safe, auto-generated Python SDK for Proxmox VE API v7.4-2.

## Features

- ✨ **100% Type-Safe**: Full type hints with Pydantic validation
- 🔄 **Auto-Generated**: Generated from official API schema
- 🎯 **Intuitive API**: Hierarchical structure mirrors Proxmox API
- 🚀 **Async/Await**: Modern async HTTP client
- 📝 **Comprehensive**: All 600+ API endpoints included
- 🛡️ **Validated**: Input/output validation with Pydantic

## Installation

```bash
pip install prmxctrl  # Not published yet
```

## Quick Start

```python
import asyncio
from prmxctrl import ProxmoxClient

async def main():
    async with ProxmoxClient(
        host='https://proxmox.example.com:8006',
        user='root@pam',
        password='your-password',
        verify_ssl=False
    ) as client:
        # Get cluster status
        status = await client.cluster.status.get()
        print(f"Cluster: {status}")
        
        # List nodes
        nodes = await client.nodes.list()
        for node in nodes:
            print(f"Node: {node['node']}")
        
        # Get VMs on a node
        vms = await client.nodes('pve1').qemu.list()
        for vm in vms:
            print(f"VM {vm['vmid']}: {vm['name']}")
        
        # Get VM configuration
        config = await client.nodes('pve1').qemu(100).config.get()
        print(f"VM Config: {config}")
        
        # Start a VM
        await client.nodes('pve1').qemu(100).status.start()

asyncio.run(main())
```

## Authentication

### Password Authentication

```python
client = ProxmoxClient(
    host='https://proxmox.example.com:8006',
    user='root@pam',
    password='secret'
)
```

### API Token Authentication

```python
client = ProxmoxClient(
    host='https://proxmox.example.com:8006',
    user='root@pam',
    token_name='my-token',
    token_value='xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
)
```

## API Structure

The SDK mirrors Proxmox's API structure:

```python
client.cluster                    # /cluster
client.cluster.config            # /cluster/config
client.nodes                     # /nodes
client.nodes('pve1')            # /nodes/pve1
client.nodes('pve1').qemu       # /nodes/pve1/qemu
client.nodes('pve1').qemu(100)  # /nodes/pve1/qemu/100
client.nodes('pve1').qemu(100).config  # /nodes/pve1/qemu/100/config
```

## Type Safety

All parameters and responses are validated:

```python
from prmxctrl.models.nodes import NodesQemuCreateParams

# Type-safe VM creation
params = NodesQemuCreateParams(
    vmid=100,
    name="my-vm",
    memory=2048,
    cores=2,
    # IDE will autocomplete all available options!
)

vm = await client.nodes('pve1').qemu.create(params)
```

## Development

### Regenerating the SDK

```bash
# Install dependencies
pip install -r requirements-dev.txt

# Regenerate from schema
python tools/generate.py --force
```

## License

MIT License

## Disclaimer

This is an unofficial SDK and is not affiliated with or endorsed by Proxmox Server Solutions GmbH.
```
