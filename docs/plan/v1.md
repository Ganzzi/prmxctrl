# Plan: Auto-Generated Hierarchical Proxmox SDK (v7.4-2)

## Core Principles
1. **100% Auto-generated** - No manual endpoint coding
2. **Hierarchical structure** - Mirror API path structure exactly
3. **Single version focus** - Perfect v7.4-2 implementation first
4. **Type-safe everything** - Pydantic models for all params/responses
5. **Developer experience** - Intuitive autocomplete and navigation

---

## Project Architecture

### Directory Structure
```
prmxctrl/
├── generator/                      # Code generation tools (not in package)
│   ├── __init__.py
│   ├── fetch_schema.py            # Download apidata.js from GitHub
│   ├── parse_schema.py            # Parse JS → structured format
│   ├── analyze_schema.py          # Analyze and validate schema
│   ├── generators/
│   │   ├── __init__.py
│   │   ├── model_generator.py     # Generate Pydantic models
│   │   ├── endpoint_generator.py  # Generate endpoint classes
│   │   ├── client_generator.py    # Generate main client
│   │   └── utils.py               # Shared utilities
│   ├── templates/                  # Jinja2 templates
│   │   ├── model.py.jinja
│   │   ├── endpoint.py.jinja
│   │   └── client.py.jinja
│   └── config.py                   # Generation configuration
│
├── prmxctrl/                    # Generated package
│   ├── __init__.py                # Export ProxmoxClient
│   ├── client.py                  # GENERATED: Main client entry
│   ├── base/                      # Hand-written base classes
│   │   ├── __init__.py
│   │   ├── http_client.py        # HTTP/Auth implementation
│   │   ├── endpoint_base.py      # Base endpoint class
│   │   ├── types.py              # Common types
│   │   └── exceptions.py         # Custom exceptions
│   │
│   ├── models/                    # GENERATED: All Pydantic models
│   │   ├── __init__.py
│   │   ├── access.py             # /access models
│   │   ├── cluster.py            # /cluster models
│   │   ├── nodes.py              # /nodes models
│   │   ├── pools.py              # /pools models
│   │   ├── storage.py            # /storage models
│   │   └── common.py             # Shared models
│   │
│   └── endpoints/                 # GENERATED: Hierarchical endpoints
│       ├── __init__.py
│       ├── access.py              # /access endpoints
│       ├── cluster.py             # /cluster endpoints
│       ├── nodes/                 # /nodes/* nested structure
│       │   ├── __init__.py
│       │   ├── _base.py          # /nodes endpoints
│       │   ├── qemu/             # /nodes/{node}/qemu/*
│       │   │   ├── __init__.py
│       │   │   ├── _base.py      # /nodes/{node}/qemu
│       │   │   ├── _item.py      # /nodes/{node}/qemu/{vmid}
│       │   │   ├── config.py     # /nodes/{node}/qemu/{vmid}/config
│       │   │   ├── status.py     # /nodes/{node}/qemu/{vmid}/status/*
│       │   │   ├── agent.py      # /nodes/{node}/qemu/{vmid}/agent/*
│       │   │   └── migrate.py
│       │   ├── lxc/              # /nodes/{node}/lxc/*
│       │   ├── storage/          # /nodes/{node}/storage/*
│       │   └── tasks/            # /nodes/{node}/tasks/*
│       ├── pools.py
│       ├── storage.py
│       └── version.py
│
├── tools/
│   ├── generate.py                # Main CLI: python tools/generate.py
│   └── validate.py                # Validate generated code
│
├── tests/
│   ├── generator/                 # Test generation logic
│   └── integration/               # Test generated SDK
│
├── schemas/
│   └── v7.4-2.json               # Parsed schema (cached)
│
├── pyproject.toml
├── README.md
└── GENERATION.md                  # How code generation works
```

---

## Phase 1: Schema Processing (Days 1-2)

### 1.1 Fetch and Parse Schema

```python
# generator/fetch_schema.py
import httpx
import re
import json

class SchemaFetcher:
    """Fetch apidata.js from GitHub commit"""
    
    COMMIT = "f42edd7afd805a27fd7a0b027d67ca7adeedc2c6"
    URL = f"https://raw.githubusercontent.com/proxmox/pve-docs/{COMMIT}/api-viewer/apidata.js"
    
    async def fetch(self) -> str:
        """Download apidata.js"""
        async with httpx.AsyncClient() as client:
            response = await client.get(self.URL)
            return response.text
    
    def extract_schema(self, js_content: str) -> str:
        """Extract 'const apiSchema = [...]' from JS"""
        # Remove comments
        js_content = re.sub(r'//.*?\n', '\n', js_content)
        js_content = re.sub(r'/\*.*?\*/', '', js_content, flags=re.DOTALL)
        
        # Find apiSchema definition
        match = re.search(r'const\s+apiSchema\s*=\s*(\[.*?\]);', js_content, re.DOTALL)
        if not match:
            raise ValueError("Could not find apiSchema in JS file")
        
        # Clean up JavaScript-specific syntax
        json_str = match.group(1)
        json_str = re.sub(r',(\s*[}\]])', r'\1', json_str)  # Remove trailing commas
        
        return json_str
    
    def parse_to_json(self, json_str: str) -> list:
        """Parse to Python object"""
        return json.loads(json_str)
    
    async def fetch_and_parse(self, cache_file: str = "schemas/v7.4-2.json"):
        """Complete pipeline with caching"""
        if os.path.exists(cache_file):
            with open(cache_file) as f:
                return json.load(f)
        
        js_content = await self.fetch()
        json_str = self.extract_schema(js_content)
        schema = self.parse_to_json(json_str)
        
        os.makedirs(os.path.dirname(cache_file), exist_ok=True)
        with open(cache_file, 'w') as f:
            json.dump(schema, f, indent=2)
        
        return schema
```

### 1.2 Schema Analysis and Structure

```python
# generator/parse_schema.py
from dataclasses import dataclass, field
from typing import Optional, Literal

@dataclass
class Parameter:
    """API parameter definition"""
    name: str
    type: str
    description: Optional[str] = None
    optional: bool = False
    default: Optional[any] = None
    format: Optional[str] = None
    minimum: Optional[int] = None
    maximum: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None
    enum: Optional[list] = None
    properties: Optional[dict] = None  # For nested objects

@dataclass
class Response:
    """API response definition"""
    type: str
    description: Optional[str] = None
    properties: Optional[dict] = None
    items: Optional[dict] = None  # For array responses

@dataclass
class Method:
    """HTTP method definition"""
    method: Literal["GET", "POST", "PUT", "DELETE"]
    name: str
    description: Optional[str] = None
    parameters: list[Parameter] = field(default_factory=list)
    returns: Optional[Response] = None
    protected: bool = False
    proxyto: Optional[str] = None
    permissions: Optional[dict] = None

@dataclass
class Endpoint:
    """API endpoint definition"""
    path: str
    text: str  # URL segment name
    leaf: bool  # True if terminal node
    methods: dict[str, Method] = field(default_factory=dict)
    children: list['Endpoint'] = field(default_factory=list)
    
    # Parsed metadata
    path_params: list[str] = field(default_factory=list)  # e.g., ['node', 'vmid']
    python_path: str = ""  # e.g., "nodes.qemu.item"
    class_name: str = ""   # e.g., "NodesQemuItemEndpoints"

class SchemaParser:
    """Parse raw schema into structured format"""
    
    def parse(self, raw_schema: list) -> list[Endpoint]:
        """Parse schema recursively"""
        return [self._parse_node(node, parent_path="") for node in raw_schema]
    
    def _parse_node(self, node: dict, parent_path: str) -> Endpoint:
        """Parse single schema node"""
        path = node['path']
        text = node['text']
        
        endpoint = Endpoint(
            path=path,
            text=text,
            leaf=node.get('leaf', 0) == 1
        )
        
        # Extract path parameters: /nodes/{node}/qemu/{vmid}
        endpoint.path_params = re.findall(r'\{(\w+)\}', path)
        
        # Parse methods (GET, POST, PUT, DELETE)
        if 'info' in node:
            for method_name, method_info in node['info'].items():
                endpoint.methods[method_name] = self._parse_method(method_name, method_info)
        
        # Parse children recursively
        if 'children' in node:
            endpoint.children = [
                self._parse_node(child, path) 
                for child in node['children']
            ]
        
        # Generate Python naming
        endpoint.python_path = self._generate_python_path(path)
        endpoint.class_name = self._generate_class_name(path)
        
        return endpoint
    
    def _parse_method(self, method_name: str, method_info: dict) -> Method:
        """Parse method definition"""
        method = Method(
            method=method_name,
            name=method_info.get('name', ''),
            description=method_info.get('description'),
            protected=method_info.get('protected', 0) == 1
        )
        
        # Parse parameters
        if 'parameters' in method_info:
            params_info = method_info['parameters']
            if 'properties' in params_info:
                method.parameters = [
                    self._parse_parameter(name, prop)
                    for name, prop in params_info['properties'].items()
                ]
        
        # Parse response
        if 'returns' in method_info:
            method.returns = self._parse_response(method_info['returns'])
        
        return method
    
    def _parse_parameter(self, name: str, prop: dict) -> Parameter:
        """Parse parameter definition"""
        return Parameter(
            name=name,
            type=prop.get('type', 'string'),
            description=prop.get('description'),
            optional=prop.get('optional', 0) == 1,
            default=prop.get('default'),
            format=prop.get('format'),
            minimum=prop.get('minimum'),
            maximum=prop.get('maximum'),
            max_length=prop.get('maxLength'),
            pattern=prop.get('pattern'),
            enum=prop.get('enum'),
            properties=prop.get('properties') or prop.get('format')  # Nested properties
        )
    
    def _generate_python_path(self, api_path: str) -> str:
        """
        Convert API path to Python attribute path
        /nodes/{node}/qemu/{vmid}/config → nodes.qemu(node).item(vmid).config
        """
        # This is simplified; actual implementation needs more logic
        parts = api_path.strip('/').split('/')
        python_parts = []
        
        for part in parts:
            if '{' in part:
                param = part.strip('{}')
                python_parts.append(f'item_{param}')
            else:
                python_parts.append(part)
        
        return '.'.join(python_parts)
    
    def _generate_class_name(self, api_path: str) -> str:
        """
        Generate class name from path
        /nodes/{node}/qemu/{vmid} → NodesQemuItemEndpoints
        """
        parts = api_path.strip('/').split('/')
        name_parts = []
        
        for part in parts:
            if '{' in part:
                name_parts.append('Item')
            else:
                name_parts.append(part.capitalize())
        
        return ''.join(name_parts) + 'Endpoints'
```

### 1.3 Schema Analyzer

```python
# generator/analyze_schema.py
class SchemaAnalyzer:
    """Analyze parsed schema to generate metadata for code generation"""
    
    def analyze(self, endpoints: list[Endpoint]) -> dict:
        """Generate complete analysis"""
        return {
            'total_endpoints': self._count_endpoints(endpoints),
            'total_methods': self._count_methods(endpoints),
            'path_tree': self._build_tree(endpoints),
            'all_endpoints': self._flatten_endpoints(endpoints),
            'parameter_types': self._collect_parameter_types(endpoints),
            'common_models': self._identify_common_models(endpoints),
        }
    
    def _build_tree(self, endpoints: list[Endpoint]) -> dict:
        """Build hierarchical tree structure for navigation"""
        tree = {}
        for endpoint in endpoints:
            self._add_to_tree(tree, endpoint)
        return tree
    
    def _identify_common_models(self, endpoints: list[Endpoint]) -> list:
        """Identify parameters/responses used across multiple endpoints"""
        # Find patterns like 'node', 'vmid', common config objects
        # These become shared models in models/common.py
        pass
```

---

## Phase 2: Base Framework & Infrastructure (2-3 days)
Hand-written base classes and configuration that supports all generated code.

### 2.1 HTTP Client Base

```python
# prmxctrl/base/http_client.py
import httpx
from typing import Optional, Any
from urllib.parse import urljoin
import json

from .exceptions import (
    ProxmoxAuthError,
    ProxmoxAPIError,
    ProxmoxConnectionError,
    ProxmoxTimeoutError
)

class HTTPClient:
    """Base HTTP client for Proxmox API"""
    
    def __init__(
        self,
        host: str,
        user: str,
        password: Optional[str] = None,
        token_name: Optional[str] = None,
        token_value: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: int = 30,
    ):
        """
        Initialize HTTP client
        
        Args:
            host: Proxmox host (e.g., https://proxmox.example.com:8006)
            user: Username (e.g., root@pam)
            password: Password for ticket-based auth
            token_name: API token name for token-based auth
            token_value: API token value for token-based auth
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        self.host = host.rstrip('/')
        self.user = user
        self.password = password
        self.token_name = token_name
        self.token_value = token_value
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        
        self._client: Optional[httpx.AsyncClient] = None
        self._ticket: Optional[str] = None
        self._csrf_token: Optional[str] = None
    
    async def __aenter__(self):
        """Async context manager entry"""
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()
    
    async def connect(self):
        """Initialize HTTP client and authenticate"""
        self._client = httpx.AsyncClient(
            verify=self.verify_ssl,
            timeout=self.timeout,
            follow_redirects=True
        )
        
        # Authenticate
        if self.token_name and self.token_value:
            # Token-based authentication
            await self._authenticate_token()
        elif self.password:
            # Ticket-based authentication
            await self._authenticate_ticket()
        else:
            raise ProxmoxAuthError("Either password or token credentials required")
    
    async def close(self):
        """Close HTTP client"""
        if self._client:
            await self._client.aclose()
            self._client = None
    
    async def _authenticate_ticket(self):
        """Authenticate with username/password to get ticket"""
        url = self._build_url('/api2/json/access/ticket')
        
        try:
            response = await self._client.post(
                url,
                data={
                    'username': self.user,
                    'password': self.password
                }
            )
            response.raise_for_status()
            
            data = response.json()['data']
            self._ticket = data['ticket']
            self._csrf_token = data['CSRFPreventionToken']
            
        except httpx.HTTPStatusError as e:
            raise ProxmoxAuthError(f"Authentication failed: {e}")
        except Exception as e:
            raise ProxmoxConnectionError(f"Connection failed: {e}")
    
    async def _authenticate_token(self):
        """Set up token-based authentication headers"""
        # Token auth doesn't require initial request
        # Headers are set in each request
        pass
    
    def _build_url(self, path: str) -> str:
        """Build full URL from path"""
        return urljoin(f"{self.host}/api2/json", path.lstrip('/'))
    
    def _get_headers(self) -> dict:
        """Get authentication headers"""
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        
        if self.token_name and self.token_value:
            # Token authentication
            headers['Authorization'] = f'PVEAPIToken={self.user}!{self.token_name}={self.token_value}'
        elif self._csrf_token:
            # Ticket authentication
            headers['CSRFPreventionToken'] = self._csrf_token
        
        return headers
    
    def _get_cookies(self) -> dict:
        """Get authentication cookies"""
        if self._ticket:
            return {'PVEAuthCookie': self._ticket}
        return {}
    
    async def request(
        self,
        method: str,
        path: str,
        params: Optional[dict] = None,
        data: Optional[dict] = None
    ) -> Any:
        """
        Make authenticated API request
        
        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            path: API path (e.g., /nodes/pve1/qemu)
            params: Query parameters (for GET)
            data: Request body (for POST/PUT)
        
        Returns:
            Parsed JSON response
        
        Raises:
            ProxmoxAPIError: API returned error
            ProxmoxTimeoutError: Request timeout
            ProxmoxConnectionError: Connection failed
        """
        if not self._client:
            raise ProxmoxConnectionError("Client not connected. Use async with or call connect()")
        
        url = self._build_url(path)
        headers = self._get_headers()
        cookies = self._get_cookies()
        
        try:
            response = await self._client.request(
                method=method,
                url=url,
                params=params,
                json=data,
                headers=headers,
                cookies=cookies
            )
            
            # Check for errors
            response.raise_for_status()
            
            # Parse response
            result = response.json()
            
            # Proxmox wraps response in 'data' key
            if isinstance(result, dict) and 'data' in result:
                return result['data']
            
            return result
            
        except httpx.TimeoutException as e:
            raise ProxmoxTimeoutError(f"Request timeout: {e}")
        except httpx.HTTPStatusError as e:
            # Try to extract error message from response
            try:
                error_data = e.response.json()
                error_msg = error_data.get('errors', str(e))
            except:
                error_msg = str(e)
            
            raise ProxmoxAPIError(
                f"API error {e.response.status_code}: {error_msg}",
                status_code=e.response.status_code
            )
        except Exception as e:
            raise ProxmoxConnectionError(f"Request failed: {e}")
    
    async def get(self, path: str, params: Optional[dict] = None) -> Any:
        """GET request"""
        return await self.request('GET', path, params=params)
    
    async def post(self, path: str, data: Optional[dict] = None) -> Any:
        """POST request"""
        return await self.request('POST', path, data=data)
    
    async def put(self, path: str, data: Optional[dict] = None) -> Any:
        """PUT request"""
        return await self.request('PUT', path, data=data)
    
    async def delete(self, path: str) -> Any:
        """DELETE request"""
        return await self.request('DELETE', path)
```

### 2.2 Custom Exceptions

```python
# prmxctrl/base/exceptions.py

class ProxmoxError(Exception):
    """Base exception for Proxmox SDK"""
    pass

class ProxmoxAuthError(ProxmoxError):
    """Authentication failed"""
    pass

class ProxmoxConnectionError(ProxmoxError):
    """Connection to Proxmox failed"""
    pass

class ProxmoxTimeoutError(ProxmoxError):
    """Request timeout"""
    pass

class ProxmoxAPIError(ProxmoxError):
    """API returned an error"""
    
    def __init__(self, message: str, status_code: Optional[int] = None):
        super().__init__(message)
        self.status_code = status_code
```

### 2.3 Endpoint Base Class

```python
# prmxctrl/base/endpoint_base.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from prmxctrl.base.http_client import HTTPClient

class EndpointBase:
    """Base class for all endpoint classes"""
    
    def __init__(self, client: 'HTTPClient', path: str = ""):
        self._client = client
        self._path = path
    
    def _build_path(self, *parts) -> str:
        """Build full API path"""
        all_parts = [self._path] + [str(p) for p in parts if p]
        return '/' + '/'.join(p.strip('/') for p in all_parts if p)
    
    async def _get(self, path: str, params: dict = None):
        """GET request helper"""
        return await self._client.get(self._build_path(path), params=params)
    
    async def _post(self, path: str, data: dict = None):
        """POST request helper"""
        return await self._client.post(self._build_path(path), data=data)
    
    async def _put(self, path: str, data: dict = None):
        """PUT request helper"""
        return await self._client.put(self._build_path(path), data=data)
    
    async def _delete(self, path: str):
        """DELETE request helper"""
        return await self._client.delete(self._build_path(path))
```

---

## Phase 3: Model Generation (4-5 days)

### 3.1 Type Mapping System

```python
# generator/generators/type_mapper.py
class TypeMapper:
    """
    Maps Proxmox API parameter specifications to Python/Pydantic types.

    Handles type conversion, constraints, and Pydantic Field generation.
    """

    # Proxmox custom formats and their Python equivalents
    FORMAT_MAPPINGS = {
        # Node-related formats
        "pve-node": "ProxmoxNode",
        "pve-node-list": "List[ProxmoxNode]",
        # VM/Container ID formats
        "pve-vmid": "ProxmoxVMID",
        "pve-vmid-list": "List[ProxmoxVMID]",
        # Storage formats
        "pve-storage-id": "str",  # Storage ID/name
        "pve-storage-id-list": "List[str]",
        # Replication formats
        "pve-replication-job-id": "str",
        "pve-replication-job-id-list": "List[str]",
        # Config ID formats
        "pve-configid-list": "str",  # Comma-separated list
        # Time formats
        "pve-timezone": "str",
        "pve-calendar-event": "str",
        # Network formats
        "pve-iface": "str",  # Network interface name
        "ipv4": "str",
        "ipv6": "str",
        "ip": "str",  # IPv4 or IPv6
        "cidr": "str",  # CIDR notation
        "mac-addr": "str",
        # Authentication formats
        "pve-userid": "str",  # User ID with realm
        "pve-realm": "str",
        # Generic formats
        "email": "str",
        "uri": "str",
        "uuid": "str",
        "hostname": "str",
    }

    @classmethod
    def map_parameter_type(
        cls, param_spec: Dict[str, Any], param_name: str = ""
    ) -> Tuple[str, Dict[str, Any]]:
        """
        Map a Proxmox parameter specification to Python type and Pydantic Field kwargs.

        Args:
            param_spec: Parameter specification from schema
            param_name: Parameter name for better error messages

        Returns:
            Tuple of (python_type_string, field_kwargs_dict)
        """
        param_type = param_spec.get("type", "string")
        is_optional = param_spec.get("optional", False)
        default_value = param_spec.get("default")

        # Handle array types
        if param_type == "array":
            return cls._map_array_type(param_spec, param_name, is_optional, default_value)

        # Handle object types
        elif param_type == "object":
            return cls._map_object_type(param_spec, param_name, is_optional, default_value)

        # Handle primitive types
        else:
            return cls._map_primitive_type(param_spec, param_name, is_optional, default_value)

    @classmethod
    def _map_primitive_type(
        cls, param_spec: Dict[str, Any], param_name: str, is_optional: bool, default_value: Any
    ) -> Tuple[str, Dict[str, Any]]:
        """Map primitive parameter types."""
        param_type = param_spec.get("type", "string")
        param_format = param_spec.get("format")

        # Base type mapping
        if param_type == "string":
            python_type = cls._map_string_type(param_spec)
        elif param_type == "integer":
            python_type = "int"
        elif param_type == "number":
            python_type = "float"
        elif param_type == "boolean":
            python_type = "bool"
        elif param_type == "null":
            python_type = "None"
        else:
            # Unknown type, default to string
            python_type = "str"

        # Apply format-specific mapping
        if param_format and param_format in cls.FORMAT_MAPPINGS:
            python_type = cls.FORMAT_MAPPINGS[param_format]

        # Handle optional types
        if is_optional:
            python_type = f"Optional[{python_type}]"

        # Build Pydantic Field kwargs
        field_kwargs = cls._build_field_kwargs(param_spec, default_value)

        return python_type, field_kwargs

    @classmethod
    def _map_string_type(cls, param_spec: Dict[str, Any]) -> str:
        """Map string type with format considerations."""
        param_format = param_spec.get("format")

        # Handle enum values
        if "enum" in param_spec and param_spec["enum"] is not None:
            enum_values = param_spec["enum"]
            if len(enum_values) <= 10:  # Use Literal for small enums
                from typing import Literal

                # Create a union of literal values
                literals = [f'"{v}"' for v in enum_values]
                return f"Literal[{', '.join(literals)}]"
            else:
                # For large enums, use str with validation
                return "str"

        # Handle format-specific types
        if param_format:
            if param_format in cls.FORMAT_MAPPINGS:
                return cls.FORMAT_MAPPINGS[param_format]
            elif param_format == "password":
                return "Password"
            elif param_format == "token":
                return "AuthToken"

        return "str"

    @classmethod
    def _map_array_type(
        cls, param_spec: Dict[str, Any], param_name: str, is_optional: bool, default_value: Any
    ) -> Tuple[str, Dict[str, Any]]:
        """Map array parameter types."""
        items_spec = param_spec.get("items", {})
        if not items_spec:
            # Generic array
            python_type = "List[Any]"
        else:
            # Typed array
            item_type, _ = cls.map_parameter_type(items_spec, f"{param_name}_item")
            python_type = f"List[{item_type}]"

        if is_optional:
            python_type = f"Optional[{python_type}]"

        field_kwargs = cls._build_field_kwargs(param_spec, default_value)

        return python_type, field_kwargs

    @classmethod
    def _map_object_type(
        cls, param_spec: Dict[str, Any], param_name: str, is_optional: bool, default_value: Any
    ) -> Tuple[str, Dict[str, Any]]:
        """Map object parameter types."""
        # For now, treat objects as generic dictionaries
        # TODO: Generate nested models for complex objects
        python_type = "Dict[str, Any]"

        if is_optional:
            python_type = f"Optional[{python_type}]"

        field_kwargs = cls._build_field_kwargs(param_spec, default_value)

        return python_type, field_kwargs

    @classmethod
    def _build_field_kwargs(cls, param_spec: Dict[str, Any], default_value: Any) -> Dict[str, Any]:
        """Build Pydantic Field kwargs from parameter constraints."""
        field_kwargs = {}

        # Description
        if "description" in param_spec:
            field_kwargs["description"] = param_spec["description"]

        # Default value
        if "default" in param_spec:
            field_kwargs["default"] = param_spec["default"]

        # Numeric constraints
        if "minimum" in param_spec:
            field_kwargs["ge"] = param_spec["minimum"]
        if "maximum" in param_spec:
            field_kwargs["le"] = param_spec["maximum"]
        if "exclusiveMinimum" in param_spec:
            field_kwargs["gt"] = param_spec["exclusiveMinimum"]
        if "exclusiveMaximum" in param_spec:
            field_kwargs["lt"] = param_spec["exclusiveMaximum"]

        # String constraints
        if "minLength" in param_spec:
            field_kwargs["min_length"] = param_spec["minLength"]
        if "maxLength" in param_spec:
            field_kwargs["max_length"] = param_spec["maxLength"]

        # Pattern validation
        if "pattern" in param_spec:
            field_kwargs["pattern"] = param_spec["pattern"]

        # Enum validation (for large enums)
        if "enum" in param_spec and param_spec["enum"] is not None and len(param_spec["enum"]) > 10:
            field_kwargs["enum"] = param_spec["enum"]

        return field_kwargs

    @classmethod
    def get_required_imports(cls, types_used: List[str]) -> List[str]:
        """
        Get required import statements for the given types.

        Args:
            types_used: List of Python type strings used in the model

        Returns:
            List of import statements
        """
        imports = set()

        # Standard typing imports
        typing_imports = set()
        pydantic_imports = set()

        for type_str in types_used:
            # Check for Optional
            if "Optional[" in type_str:
                typing_imports.add("Optional")

            # Check for List
            if "List[" in type_str:
                typing_imports.add("List")

            # Check for Dict
            if "Dict[" in type_str:
                typing_imports.add("Dict")

            # Check for Literal
            if "Literal[" in type_str:
                typing_imports.add("Literal")

            # Check for Pydantic types
            if "Field(" in type_str:
                pydantic_imports.add("Field")

            # Check for custom types
            if "ProxmoxNode" in type_str:
                imports.add("from ..types import ProxmoxNode")
            if "ProxmoxVMID" in type_str:
                imports.add("from ..types import ProxmoxVMID")
            if "Password" in type_str:
                imports.add("from ..types import Password")
            if "AuthToken" in type_str:
                imports.add("from ..types import AuthToken")

        # Add typing imports
        if typing_imports:
            imports.add(f"from typing import {', '.join(sorted(typing_imports))}")

        # Add Pydantic imports
        if pydantic_imports:
            imports.add(f"from pydantic import {', '.join(sorted(pydantic_imports))}")

        return sorted(imports)
```

### 3.2 Model Generator

```python
# generator/generators/model_generator.py
"""
Model generation utilities for Proxmox API schema.

This module generates Pydantic v2 models from parsed schema endpoints,
creating type-safe request and response models.
"""

from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass
from collections import defaultdict
import re

from ..parse_schema import Endpoint, Method, Parameter
from .type_mapper import TypeMapper


@dataclass
class ModelField:
    """Represents a field in a Pydantic model."""

    name: str
    type_annotation: str
    field_kwargs: Dict[str, Any]
    description: Optional[str] = None


@dataclass
class PydanticModel:
    """Represents a complete Pydantic model."""

    name: str
    fields: List[ModelField]
    docstring: Optional[str] = None
    base_class: str = "BaseModel"


@dataclass
class ModelFile:
    """Represents a complete Python file with multiple models."""

    filename: str
    models: List[PydanticModel]
    imports: List[str]


class ModelGenerator:
    """
    Generates Pydantic v2 models from parsed Proxmox API schema.

    Creates request models for method parameters and response models
    for return types, with proper type annotations and validation.
    """

    def __init__(self):
        self.type_mapper = TypeMapper()
        self.generated_models: Dict[str, PydanticModel] = {}
        self.model_counter = defaultdict(int)

    def generate_models(self, endpoints: List[Endpoint]) -> List[ModelFile]:
        """
        Generate Pydantic models for all endpoints.

        Args:
            endpoints: List of parsed Endpoint objects

        Returns:
            List of ModelFile objects containing the generated models
        """
        # Collect all models by module
        models_by_module: Dict[str, List[PydanticModel]] = defaultdict(list)

        def process_endpoint(endpoint: Endpoint):
            """Process a single endpoint and its methods."""
            module_name = self._get_module_name(endpoint)

            # Generate models for each method
            for method_name, method in endpoint.methods.items():
                # Request model
                if method.parameters:
                    request_model = self._generate_request_model(endpoint, method_name, method)
                    if request_model:
                        models_by_module[module_name].append(request_model)

                # Response model
                if method.returns and method.returns.type != "null":
                    response_model = self._generate_response_model(endpoint, method_name, method)
                    if response_model:
                        models_by_module[module_name].append(response_model)

            # Process children
            for child in endpoint.children:
                process_endpoint(child)

        # Process all endpoints
        for endpoint in endpoints:
            process_endpoint(endpoint)

        # Convert to ModelFile objects
        model_files = []
        for module_name, models in models_by_module.items():
            if models:  # Only create files with models
                model_file = self._create_model_file(module_name, models)
                model_files.append(model_file)

        return model_files

    def _generate_request_model(
        self, endpoint: Endpoint, method_name: str, method: Method
    ) -> Optional[PydanticModel]:
        """Generate a request model for method parameters."""
        if not method.parameters:
            return None

        # Generate model name
        model_name = self._generate_model_name(endpoint, method_name, "Request")

        fields = []
        types_used = set()

        for param in method.parameters:
            # Map parameter type
            param_spec = {
                "type": param.type,
                "format": param.format,
                "minimum": param.minimum,
                "maximum": param.maximum,
                "maxLength": param.max_length,
                "pattern": param.pattern,
                "enum": param.enum,
                "properties": param.properties,
            }
            type_annotation, field_kwargs = self.type_mapper.map_parameter_type(
                param_spec, param.name
            )

            # Track types used for imports
            types_used.add(type_annotation)

            # Create field
            field = ModelField(
                name=self._sanitize_field_name(param.name),
                type_annotation=type_annotation,
                field_kwargs=field_kwargs,
                description=param.description,
            )
            fields.append(field)

        if not fields:
            return None

        # Create model
        model = PydanticModel(
            name=model_name,
            fields=fields,
            docstring=f"Request model for {endpoint.path} {method_name.upper()}",
        )

        # Store for potential reuse
        self.generated_models[model_name] = model

        return model

    def _generate_response_model(
        self, endpoint: Endpoint, method_name: str, method: Method
    ) -> Optional[PydanticModel]:
        """Generate a response model for method returns."""
        if not method.returns or method.returns.type == "null":
            return None

        # Generate model name
        model_name = self._generate_model_name(endpoint, method_name, "Response")

        # For now, create a simple response model
        # TODO: Handle complex response schemas
        if method.returns.type == "object":
            type_annotation = "Dict[str, Any]"
        elif method.returns.type == "array":
            # Check if items are specified
            if hasattr(method.returns, "items") and method.returns.items:
                item_type, _ = self.type_mapper.map_parameter_type(method.returns.items, "item")
                type_annotation = f"List[{item_type}]"
            else:
                type_annotation = "List[Any]"
        else:
            # Primitive type
            type_annotation, _ = self.type_mapper.map_parameter_type(
                {"type": method.returns.type}, "response"
            )

        # Create a simple response model with a single 'data' field
        field = ModelField(
            name="data",
            type_annotation=type_annotation,
            field_kwargs={"description": f"Response data for {method_name.upper()}"},
        )

        model = PydanticModel(
            name=model_name,
            fields=[field],
            docstring=f"Response model for {endpoint.path} {method_name.upper()}",
        )

        # Store for potential reuse
        self.generated_models[model_name] = model

        return model

    def _generate_model_name(self, endpoint: Endpoint, method_name: str, suffix: str) -> str:
        """Generate a unique model name."""
        # Use endpoint path components to create a meaningful name
        path_parts = [p for p in endpoint.path.split("/") if p and not p.startswith("{")]

        if path_parts:
            # Use the last meaningful path component
            base_name = path_parts[-1].replace("-", "_").title()
        else:
            base_name = "Api"

        # Add method and suffix
        method_part = method_name.upper()
        model_name = f"{base_name}{method_part}{suffix}"

        # Ensure uniqueness
        counter = self.model_counter[model_name]
        self.model_counter[model_name] += 1

        if counter > 0:
            model_name = f"{model_name}{counter}"

        return model_name

    def _get_module_name(self, endpoint: Endpoint) -> str:
        """Get the module name for an endpoint."""
        path_parts = endpoint.path.strip("/").split("/")

        # Use the first path component as module name
        if path_parts and path_parts[0]:
            return path_parts[0]
        else:
            return "common"

    def _sanitize_field_name(self, name: str) -> str:
        """Sanitize field names to be valid Python identifiers."""
        # Replace invalid characters
        name = re.sub(r"[^a-zA-Z0-9_]", "_", name)

        # Ensure it doesn't start with a digit
        if name and name[0].isdigit():
            name = f"field_{name}"

        # Ensure it's not a Python keyword
        python_keywords = {
            "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "False", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "None", "nonlocal", "not", "or", "pass", "raise", "return", "True", "try", "while", "with", "yield",
        }

        if name in python_keywords:
            name = f"{name}_"

        return name

    def _create_model_file(self, module_name: str, models: List[PydanticModel]) -> ModelFile:
        """Create a ModelFile from a list of models."""
        # Collect all types used across models
        all_types = set()
        for model in models:
            for field in model.fields:
                all_types.add(field.type_annotation)

        # Generate imports
        imports = self.type_mapper.get_required_imports(list(all_types))

        # Add base Pydantic import
        imports.insert(0, "from pydantic import BaseModel, Field")

        # Create filename
        filename = f"{module_name}.py"

        return ModelFile(filename=filename, models=models, imports=imports)
```

### 3.3 Model Template

```jinja2
{# generator/templates/model.py.jinja #}
"""
Generated Pydantic models for {{ module_name }}
Auto-generated from Proxmox VE API schema v7.4-2
DO NOT EDIT MANUALLY
"""

from typing import Optional, Literal, Any
from pydantic import BaseModel, Field, conint, constr
{% for import in imports %}
{{ import }}
{% endfor %}

{% for model in models %}
class {{ model.name }}(BaseModel):
    """{{ model.docstring or 'Auto-generated model' }}"""
    
    {% if model.type == 'request' or (model.type == 'response' and model.fields) %}
    {% for field in model.fields %}
    {{ field.name }}: {{ field.type }}{% if field.constraints %} = Field(
        {% if not field.optional and 'default' not in field.constraints %}...{% endif %}
        {% for key, value in field.constraints.items() %}
        {% if key == 'description' %}
        {{ key }}="{{ value }}"
        {% else %}
        {{ key }}={{ value }}
        {% endif %}
        {% if not loop.last %},{% endif %}
        {% endfor %}
    ){% elif field.optional %} = None{% endif %}
    {% endfor %}
    {% elif model.is_list %}
    __root__: list[{{ model.item_type }}]
    {% else %}
    __root__: {{ model.simple_type }}
    {% endif %}
    
    class Config:
        extra = 'forbid'  # Strict validation

{% endfor %}
```

---

## Phase 4: Endpoint Generation (5-6 days)

### 4.1 Hierarchical Endpoint Structure

The key insight: **Mirror the API path structure in Python classes with method chaining**

```python
# Example of desired usage:
async with ProxmoxClient(...) as client:
    # GET /nodes/{node}/qemu
    vms = await client.nodes("pve1").qemu.list()
    
    # GET /nodes/{node}/qemu/{vmid}/config
    config = await client.nodes("pve1").qemu(100).config.get()
    
    # POST /nodes/{node}/qemu/{vmid}/status/start
    await client.nodes("pve1").qemu(100).status.start()
    
    # POST /nodes/{node}/qemu/{vmid}/agent/exec
    result = await client.nodes("pve1").qemu(100).agent.exec(command="ls")
```

### 4.2 Endpoint Base Class

```python
# prmxctrl/base/endpoint_base.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from prmxctrl.base.http_client import HTTPClient

class EndpointBase:
    """Base class for all endpoint classes"""
    
    def __init__(self, client: 'HTTPClient', path: str = ""):
        self._client = client
        self._path = path
    
    def _build_path(self, *parts) -> str:
        """Build full API path"""
        all_parts = [self._path] + [str(p) for p in parts if p]
        return '/' + '/'.join(p.strip('/') for p in all_parts if p)
    
    async def _get(self, path: str, params: dict = None):
        """GET request helper"""
        return await self._client.get(self._build_path(path), params=params)
    
    async def _post(self, path: str, data: dict = None):
        """POST request helper"""
        return await self._client.post(self._build_path(path), data=data)
    
    async def _put(self, path: str, data: dict = None):
        """PUT request helper"""
        return await self._client.put(self._build_path(path), data=data)
    
    async def _delete(self, path: str):
        """DELETE request helper"""
        return await self._client.delete(self._build_path(path))
```

### 4.3 Endpoint Generator

```python
# generator/generators/endpoint_generator.py
class EndpointGenerator:
    """Generate endpoint classes with hierarchical structure"""
    
    def generate_endpoint_file(self, endpoint: Endpoint, children: list[Endpoint]) -> str:
        """
        Generate endpoint file with class and sub-endpoints
        
        For /nodes/{node}/qemu, generates:
        - NodesQemuEndpoints class with list() method
        - __call__ method returning NodesQemuItemEndpoints
        - Properties for sub-endpoints (config, status, agent, etc.)
        """
        
        # Determine file structure
        has_methods = len(endpoint.methods) > 0
        has_children = len(children) > 0
        has_path_params = len(endpoint.path_params) > 0
        
        classes = []
        
        # Generate main endpoint class
        if has_methods or has_children:
            classes.append(self._generate_endpoint_class(endpoint, children))
        
        # Generate item class if has path parameters
        if has_path_params and children:
            classes.append(self._generate_item_class(endpoint, children))
        
        template = self.env.get_template('endpoint.py.jinja')
        return template.render(
            endpoint=endpoint,
            classes=classes,
            imports=self._collect_imports(endpoint, children)
        )
    
    def _generate_endpoint_class(self, endpoint: Endpoint, children: list[Endpoint]) -> dict:
        """
        Generate main endpoint class
        Example: NodesQemuEndpoints
        """
        class_info = {
            'name': endpoint.class_name,
            'methods': [],
            'properties': [],
            'callable': len(endpoint.path_params) > 0
        }
        
        # Generate API methods (GET, POST, etc.)
        for method in endpoint.methods.values():
            class_info['methods'].append(self._generate_method(endpoint, method))
        
        # Generate properties for child endpoints
        for child in children:
            if not child.path_params:  # Only direct children, not parameterized
                class_info['properties'].append({
                    'name': child.text,
                    'class': child.class_name,
                    'path': child.text
                })
        
        # Generate __call__ if this endpoint has path parameters
        if endpoint.path_params:
            class_info['call_method'] = self._generate_call_method(endpoint)
        
        return class_info
    
    def _generate_method(self, endpoint: Endpoint, method: Method) -> dict:
        """
        Generate a single API method
        
        Example:
        async def list(self, params: NodesQemuListParams = None) -> NodesQemuListResponse:
            ...
        """
        method_name = self._get_method_name(method)
        
        # Determine parameter model
        param_model = None
        if method.parameters:
            param_model = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Params"
        
        # Determine response model
        response_model = None
        if method.returns:
            response_model = f"{endpoint.class_name.replace('Endpoints', '')}{method.name.capitalize()}Response"
        
        return {
            'name': method_name,
            'http_method': method.method,
            'param_model': param_model,
            'response_model': response_model,
            'description': method.description,
            'path': '',  # Use current path
        }
    
    def _get_method_name(self, method: Method) -> str:
        """
        Convert method info to Python method name
        GET -> get() or list()
        POST -> create() or action name
        PUT -> update()
        DELETE -> delete()
        """
        if method.method == 'GET':
            # If returns array, call it list(), otherwise get()
            if method.returns and method.returns.type == 'array':
                return 'list'
            return 'get'
        elif method.method == 'POST':
            # Use the method name from schema
            return method.name or 'create'
        elif method.method == 'PUT':
            return method.name or 'update'
        elif method.method == 'DELETE':
            return 'delete'
    
    def _generate_call_method(self, endpoint: Endpoint) -> dict:
        """
        Generate __call__ method for parameterized access
        
        Example:
        def __call__(self, vmid: int) -> NodesQemuItemEndpoints:
            return NodesQemuItemEndpoints(self._client, self._path, vmid)
        """
        param_name = endpoint.path_params[0]  # Assume single param for now
        item_class = endpoint.class_name.replace('Endpoints', 'ItemEndpoints')
        
        return {
            'param_name': param_name,
            'param_type': 'int' if 'id' in param_name else 'str',
            'item_class': item_class
        }
    
    def _generate_item_class(self, endpoint: Endpoint, children: list[Endpoint]) -> dict:
        """
        Generate item class for parameterized endpoints
        Example: NodesQemuItemEndpoints (for specific vmid)
        """
        item_class = endpoint.class_name.replace('Endpoints', 'ItemEndpoints')
        param_name = endpoint.path_params[0]
        
        class_info = {
            'name': item_class,
            'param_name': param_name,
            'param_type': 'int' if 'id' in param_name else 'str',
            'methods': [],
            'properties': []
        }
        
        # Methods that operate on the item
        for child in children:
            if child.methods:
                # This child has methods, make it a property
                class_info['properties'].append({
                    'name': child.text,
                    'class': child.class_name,
                    'path': child.text
                })
        
        return class_info
```

### 4.4 Endpoint Template

```jinja2
{# generator/templates/endpoint.py.jinja #}
"""
Generated endpoint classes for {{ endpoint.path }}
Auto-generated from Proxmox VE API schema v7.4-2
DO NOT EDIT MANUALLY
"""

from typing import Optional
from prmxctrl.base.endpoint_base import EndpointBase
{% for import in imports %}
{{ import }}
{% endfor %}

{% for class in classes %}
class {{ class.name }}(EndpointBase):
    """Endpoint class for {{ endpoint.path }}"""
    
    {% if class.properties %}
    # Sub-endpoint properties
    {% for prop in class.properties %}
    @property
    def {{ prop.name }}(self) -> '{{ prop.class }}':
        """Access {{ prop.path }} endpoints"""
        from .{{ prop.name }} import {{ prop.class }}
        return {{ prop.class }}(self._client, self._build_path("{{ prop.path }}"))
    
    {% endfor %}
    {% endif %}
    
    {% if class.callable %}
    def __call__(self, {{ class.call_method.param_name }}: {{ class.call_method.param_type }}) -> '{{ class.call_method.item_class }}':
        """Access specific {{ class.call_method.param_name }}"""
        return {{ class.call_method.item_class }}(
            self._client, 
            self._build_path(str({{ class.call_method.param_name }}))
        )
    
    {% endif %}

    {% for method in class.methods %}
    async def {{ method.name }}(
        self
        {%- if method.param_model -%}
        , params: Optional['{{ method.param_model }}'] = None
        {%- endif -%}
    ) -> {% if method.response_model %}'{{ method.response_model }}'{% else %}dict{% endif %}:
        """
        {{ method.description or 'API method' }}
        
        {% if method.http_method == 'GET' %}
        HTTP Method: GET
        {% elif method.http_method == 'POST' %}
        HTTP Method: POST
        {% elif method.http_method == 'PUT' %}
        HTTP Method: PUT
        {% elif method.http_method == 'DELETE' %}
        HTTP Method: DELETE
        {% endif %}
        """
        {% if method.http_method == 'GET' %}
        response = await self._get(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , params=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'POST' %}
        response = await self._post(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , data=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'PUT' %}
        response = await self._put(
            "{{ method.path }}"
            {%- if method.param_model -%}
            , data=params.model_dump(exclude_none=True) if params else None
            {%- endif -%}
        )
        {% elif method.http_method == 'DELETE' %}
        response = await self._delete("{{ method.path }}")
        {% endif %}
        
        {% if method.response_model %}
        return {{ method.response_model }}(**response)
        {% else %}
        return response
        {% endif %}
    
    {% endfor %}

{% endfor %}
```

---

## Phase 5: Client Generation & Integration (2-3 days)

### 5.1 HTTP Client Base

```python
# prmxctrl/base/http_client.py
import httpx
from typing import Optional, Any
from urllib.parse import urljoin
import json

from .exceptions import (
    ProxmoxAuthError,
    ProxmoxAPIError,
    ProxmoxConnectionError,
    ProxmoxTimeoutError
)

class HTTPClient:
    """Base HTTP client for Proxmox API"""
    
    def __init__(
        self,
        host: str,
        user: str,
        password: Optional[str] = None,
        token_name: Optional[str] = None,
        token_value: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: int = 30,
    ):
        """
        Initialize HTTP client
        
        Args:
            host: Proxmox host (e.g., https://proxmox.example.com:8006)
            user: Username (e.g., root@pam)
            password: Password for ticket-based auth
            token_name: API token name for token-based auth
            token_value: API token value for token-based auth
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        self.host = host.rstrip('/')
        self.user = user
        self.password = password
        self.token_name = token_name
        self.token_value = token_value
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        
        self._client: Optional[httpx.AsyncClient] = None
        self._ticket: Optional[str] = None
        self._csrf_token: Optional[str] = None
    
    async def __aenter__(self):
        """Async context manager entry"""
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()
    
    async def connect(self):
        """Initialize HTTP client and authenticate"""
        self._client = httpx.AsyncClient(
            verify=self.verify_ssl,
            timeout=self.timeout,
            follow_redirects=True
        )
        
        # Authenticate
        if self.token_name and self.token_value:
            # Token-based authentication
            await self._authenticate_token()
        elif self.password:
            # Ticket-based authentication
            await self._authenticate_ticket()
        else:
            raise ProxmoxAuthError("Either password or token credentials required")
    
    async def close(self):
        """Close HTTP client"""
        if self._client:
            await self._client.aclose()
            self._client = None
    
    async def _authenticate_ticket(self):
        """Authenticate with username/password to get ticket"""
        url = self._build_url('/api2/json/access/ticket')
        
        try:
            response = await self._client.post(
                url,
                data={
                    'username': self.user,
                    'password': self.password
                }
            )
            response.raise_for_status()
            
            data = response.json()['data']
            self._ticket = data['ticket']
            self._csrf_token = data['CSRFPreventionToken']
            
        except httpx.HTTPStatusError as e:
            raise ProxmoxAuthError(f"Authentication failed: {e}")
        except Exception as e:
            raise ProxmoxConnectionError(f"Connection failed: {e}")
    
    async def _authenticate_token(self):
        """Set up token-based authentication headers"""
        # Token auth doesn't require initial request
        # Headers are set in each request
        pass
    
    def _build_url(self, path: str) -> str:
        """Build full URL from path"""
        return urljoin(f"{self.host}/api2/json", path.lstrip('/'))
    
    def _get_headers(self) -> dict:
        """Get authentication headers"""
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        
        if self.token_name and self.token_value:
            # Token authentication
            headers['Authorization'] = f'PVEAPIToken={self.user}!{self.token_name}={self.token_value}'
        elif self._csrf_token:
            # Ticket authentication
            headers['CSRFPreventionToken'] = self._csrf_token
        
        return headers
    
    def _get_cookies(self) -> dict:
        """Get authentication cookies"""
        if self._ticket:
            return {'PVEAuthCookie': self._ticket}
        return {}
    
    async def request(
        self,
        method: str,
        path: str,
        params: Optional[dict] = None,
        data: Optional[dict] = None
    ) -> Any:
        """
        Make authenticated API request
        
        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            path: API path (e.g., /nodes/pve1/qemu)
            params: Query parameters (for GET)
            data: Request body (for POST/PUT)
        
        Returns:
            Parsed JSON response
        
        Raises:
            ProxmoxAPIError: API returned error
            ProxmoxTimeoutError: Request timeout
            ProxmoxConnectionError: Connection failed
        """
        if not self._client:
            raise ProxmoxConnectionError("Client not connected. Use async with or call connect()")
        
        url = self._build_url(path)
        headers = self._get_headers()
        cookies = self._get_cookies()
        
        try:
            response = await self._client.request(
                method=method,
                url=url,
                params=params,
                json=data,
                headers=headers,
                cookies=cookies
            )
            
            # Check for errors
            response.raise_for_status()
            
            # Parse response
            result = response.json()
            
            # Proxmox wraps response in 'data' key
            if isinstance(result, dict) and 'data' in result:
                return result['data']
            
            return result
            
        except httpx.TimeoutException as e:
            raise ProxmoxTimeoutError(f"Request timeout: {e}")
        except httpx.HTTPStatusError as e:
            # Try to extract error message from response
            try:
                error_data = e.response.json()
                error_msg = error_data.get('errors', str(e))
            except:
                error_msg = str(e)
            
            raise ProxmoxAPIError(
                f"API error {e.response.status_code}: {error_msg}",
                status_code=e.response.status_code
            )
        except Exception as e:
            raise ProxmoxConnectionError(f"Request failed: {e}")
    
    async def get(self, path: str, params: Optional[dict] = None) -> Any:
        """GET request"""
        return await self.request('GET', path, params=params)
    
    async def post(self, path: str, data: Optional[dict] = None) -> Any:
        """POST request"""
        return await self.request('POST', path, data=data)
    
    async def put(self, path: str, data: Optional[dict] = None) -> Any:
        """PUT request"""
        return await self.request('PUT', path, data=data)
    
    async def delete(self, path: str) -> Any:
        """DELETE request"""
        return await self.request('DELETE', path)
```

### 5.2 Custom Exceptions

```python
# prmxctrl/base/exceptions.py

class ProxmoxError(Exception):
    """Base exception for Proxmox SDK"""
    pass

class ProxmoxAuthError(ProxmoxError):
    """Authentication failed"""
    pass

class ProxmoxConnectionError(ProxmoxError):
    """Connection to Proxmox failed"""
    pass

class ProxmoxTimeoutError(ProxmoxError):
    """Request timeout"""
    pass

class ProxmoxAPIError(ProxmoxError):
    """API returned an error"""
    
    def __init__(self, message: str, status_code: Optional[int] = None):
        super().__init__(message)
        self.status_code = status_code
```

### 5.3 Main Client Generator

```python
# generator/generators/client_generator.py
class ClientGenerator:
    """Generate main ProxmoxClient class"""
    
    def generate(self, root_endpoints: list[Endpoint]) -> str:
        """
        Generate main client with all top-level endpoints as properties
        
        Example:
        class ProxmoxClient(HTTPClient):
            @property
            def access(self) -> AccessEndpoints: ...
            
            @property
            def cluster(self) -> ClusterEndpoints: ...
            
            @property
            def nodes(self) -> NodesEndpoints: ...
            
            ...
        """
        
        # Get all top-level endpoints
        top_level = []
        for endpoint in root_endpoints:
            top_level.append({
                'name': endpoint.text,
                'class': endpoint.class_name,
                'module': endpoint.text,
                'description': self._get_description(endpoint)
            })
        
        template = self.env.get_template('client.py.jinja')
        return template.render(
            endpoints=top_level,
            version='7.4-2'
        )
    
    def _get_description(self, endpoint: Endpoint) -> str:
        """Extract description from endpoint"""
        # Try to get description from GET method
        if 'GET' in endpoint.methods:
            return endpoint.methods['GET'].description or f'{endpoint.text} endpoints'
        return f'{endpoint.text} endpoints'
```

### 5.4 Client Template

```jinja2
{# generator/templates/client.py.jinja #}
"""
Proxmox VE API Client v{{ version }}
Auto-generated from Proxmox VE API schema
DO NOT EDIT MANUALLY
"""

from typing import Optional
from prmxctrl.base.http_client import HTTPClient
{% for endpoint in endpoints %}
from prmxctrl.endpoints.{{ endpoint.module }} import {{ endpoint.class }}
{% endfor %}

class ProxmoxClient(HTTPClient):
    """
    Main Proxmox VE API Client
    
    This client provides type-safe access to all Proxmox VE API endpoints.
    All endpoints are auto-generated from the official API schema.
    
    Example:
        async with ProxmoxClient(
            host='https://proxmox.example.com:8006',
            user='root@pam',
            password='secret',
            verify_ssl=False
        ) as client:
            # List all nodes
            nodes = await client.nodes.list()
            
            # Get VM config
            config = await client.nodes('pve1').qemu(100).config.get()
            
            # Start VM
            await client.nodes('pve1').qemu(100).status.start()
    """
    
    def __init__(
        self,
        host: str,
        user: str,
        password: Optional[str] = None,
        token_name: Optional[str] = None,
        token_value: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: int = 30,
    ):
        """
        Initialize Proxmox client
        
        Args:
            host: Proxmox host URL (e.g., https://proxmox.example.com:8006)
            user: Username (e.g., root@pam)
            password: Password for ticket auth
            token_name: API token name for token auth
            token_value: API token value for token auth
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        super().__init__(
            host=host,
            user=user,
            password=password,
            token_name=token_name,
            token_value=token_value,
            verify_ssl=verify_ssl,
            timeout=timeout
        )
    
    {% for endpoint in endpoints %}
    @property
    def {{ endpoint.name }}(self) -> {{ endpoint.class }}:
        """{{ endpoint.description }}"""
        return {{ endpoint.class }}(self, "/{{ endpoint.name }}")
    
    {% endfor %}
    
    async def get_version(self) -> dict:
        """Get Proxmox VE version"""
        return await self.get('/version')
```

---

## Phase 6: Testing & Validation (3-4 days)

### 6.1 Main Generation Script

```python
# tools/generate.py
import asyncio
import sys
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from generator.fetch_schema import SchemaFetcher
from generator.parse_schema import SchemaParser
from generator.analyze_schema import SchemaAnalyzer
from generator.generators.model_generator import ModelGenerator
from generator.generators.endpoint_generator import EndpointGenerator
from generator.generators.client_generator import ClientGenerator

app = typer.Typer()
console = Console()

class SDKGenerator:
    """Complete SDK generation pipeline"""
    
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.fetcher = SchemaFetcher()
        self.parser = SchemaParser()
        self.analyzer = SchemaAnalyzer()
        self.model_gen = ModelGenerator()
        self.endpoint_gen = EndpointGenerator()
        self.client_gen = ClientGenerator()
    
    async def generate(self):
        """Run complete generation pipeline"""
        
        console.print("[bold blue]Starting SDK generation for Proxmox VE 7.4-2[/bold blue]")
        
        # Step 1: Fetch schema
        console.print("\n[yellow]Step 1:[/yellow] Fetching API schema from GitHub...")
        raw_schema = await self.fetcher.fetch_and_parse()
        console.print(f"[green]✓[/green] Fetched {len(raw_schema)} top-level endpoints")
        
        # Step 2: Parse schema
        console.print("\n[yellow]Step 2:[/yellow] Parsing schema...")
        endpoints = self.parser.parse(raw_schema)
        console.print(f"[green]✓[/green] Parsed schema structure")
        
        # Step 3: Analyze schema
        console.print("\n[yellow]Step 3:[/yellow] Analyzing schema...")
        analysis = self.analyzer.analyze(endpoints)
        console.print(f"[green]✓[/green] Found {analysis['total_endpoints']} endpoints")
        console.print(f"[green]✓[/green] Found {analysis['total_methods']} methods")
        
        # Step 4: Generate models
        console.print("\n[yellow]Step 4:[/yellow] Generating Pydantic models...")
        await self._generate_models(endpoints)
        console.print(f"[green]✓[/green] Generated model files")
        
        # Step 5: Generate endpoints
        console.print("\n[yellow]Step 5:[/yellow] Generating endpoint classes...")
        await self._generate_endpoints(endpoints)
        console.print(f"[green]✓[/green] Generated endpoint files")
        
        # Step 6: Generate main client
        console.print("\n[yellow]Step 6:[/yellow] Generating main client...")
        await self._generate_client(endpoints)
        console.print(f"[green]✓[/green] Generated ProxmoxClient")
        
        # Step 7: Format code
        console.print("\n[yellow]Step 7:[/yellow] Formatting generated code...")
        await self._format_code()
        console.print(f"[green]✓[/green] Formatted with black")
        
        console.print("\n[bold green]✨ SDK generation complete![/bold green]")
    
    async def _generate_models(self, endpoints: list):
        """Generate all model files"""
        models_dir = self.output_dir / 'models'
        models_dir.mkdir(parents=True, exist_ok=True)
        
        # Group endpoints by top-level module
        modules = {}
        for endpoint in endpoints:
            module_name = endpoint.text
            if module_name not in modules:
                modules[module_name] = []
            
            # Collect all endpoints in this module recursively
            self._collect_endpoints(endpoint, modules[module_name])
        
        # Generate model file for each module
        for module_name, module_endpoints in modules.items():
            code = self.model_gen.generate_models_file(module_endpoints, module_name)
            
            output_file = models_dir / f'{module_name}.py'
            output_file.write_text(code)
        
        # Generate __init__.py
        init_file = models_dir / '__init__.py'
        init_code = '"""Generated Pydantic models"""\n'
        init_file.write_text(init_code)
    
    async def _generate_endpoints(self, endpoints: list):
        """Generate all endpoint files"""
        endpoints_dir = self.output_dir / 'endpoints'
        endpoints_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate endpoints recursively
        for endpoint in endpoints:
            await self._generate_endpoint_tree(endpoint, endpoints_dir)
        
        # Generate __init__.py
        init_file = endpoints_dir / '__init__.py'
        init_code = '"""Generated endpoint classes"""\n'
        init_file.write_text(init_code)
    
    async def _generate_endpoint_tree(self, endpoint, parent_dir: Path):
        """
        Generate endpoint file/directory structure recursively
        
        For /nodes, creates:
        - endpoints/nodes/__init__.py (NodesEndpoints)
        - endpoints/nodes/_base.py (node-level methods)
        - endpoints/nodes/qemu/ (subdirectory for qemu endpoints)
        """
        
        # Determine if this needs a directory or just a file
        has_children = len(endpoint.children) > 0
        has_nested_children = any(len(child.children) > 0 for child in endpoint.children)
        
        if has_nested_children:
            # Create directory for this endpoint
            endpoint_dir = parent_dir / endpoint.text
            endpoint_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate main file
            code = self.endpoint_gen.generate_endpoint_file(endpoint, endpoint.children)
            output_file = endpoint_dir / '__init__.py'
            output_file.write_text(code)
            
            # Generate children recursively
            for child in endpoint.children:
                await self._generate_endpoint_tree(child, endpoint_dir)
        else:
            # Simple endpoint, single file
            code = self.endpoint_gen.generate_endpoint_file(endpoint, endpoint.children)
            output_file = parent_dir / f'{endpoint.text}.py'
            output_file.write_text(code)
    
    async def _generate_client(self, endpoints: list):
        """Generate main client file"""
        code = self.client_gen.generate(endpoints)
        
        output_file = self.output_dir / 'client.py'
        output_file.write_text(code)
        
        # Also update __init__.py
        init_file = self.output_dir / '__init__.py'
        init_code = '''"""
Proxmox VE Python SDK
Auto-generated type-safe client for Proxmox VE API v7.4-2
"""

from prmxctrl.client import ProxmoxClient

__version__ = "0.1.0"
__all__ = ["ProxmoxClient"]
'''
        init_file.write_text(init_code)
    
    async def _format_code(self):
        """Format generated code with black"""
        import subprocess
        
        try:
            subprocess.run(
                ['black', str(self.output_dir)],
                check=True,
                capture_output=True
            )
        except subprocess.CalledProcessError as e:
            console.print(f"[yellow]Warning: black formatting failed: {e}[/yellow]")
        except FileNotFoundError:
            console.print("[yellow]Warning: black not found, skipping formatting[/yellow]")
    
    def _collect_endpoints(self, endpoint, collection: list):
        """Recursively collect all endpoints"""
        collection.append(endpoint)
        for child in endpoint.children:
            self._collect_endpoints(child, collection)

@app.command()
def generate(
    output_dir: Path = typer.Option(
        Path("prmxctrl"),
        "--output",
        "-o",
        help="Output directory for generated SDK"
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force regeneration even if output exists"
    )
):
    """Generate Proxmox VE SDK from API schema"""
    
    if output_dir.exists() and not force:
        console.print(f"[red]Error:[/red] Output directory {output_dir} already exists")
        console.print("Use --force to regenerate")
        raise typer.Exit(1)
    
    generator = SDKGenerator(output_dir)
    asyncio.run(generator.generate())

if __name__ == "__main__":
    app()
```

### 6.2 Usage

```bash
# Generate complete SDK
python tools/generate.py

# Regenerate (overwrite existing)
python tools/generate.py --force

# Custom output directory
python tools/generate.py --output my_sdk
```

---

## Phase 7: Documentation & Polish (2-3 days)

### 7.1 Test Structure

```python
# tests/conftest.py
import pytest
import os
from prmxctrl import ProxmoxClient

@pytest.fixture
def proxmox_host():
    return os.getenv('PROXMOX_HOST', 'https://proxmox.test:8006')

@pytest.fixture
def proxmox_user():
    return os.getenv('PROXMOX_USER', 'root@pam')

@pytest.fixture
def proxmox_password():
    return os.getenv('PROXMOX_PASSWORD', 'test')

@pytest.fixture
async def client(proxmox_host, proxmox_user, proxmox_password):
    """Provide authenticated client"""
    async with ProxmoxClient(
        host=proxmox_host,
        user=proxmox_user,
        password=proxmox_password,
        verify_ssl=False
    ) as client:
        yield client
```

```python
# tests/test_client.py
import pytest

@pytest.mark.asyncio
async def test_client_connection(client):
    """Test basic client connection"""
    version = await client.get_version()
    assert 'version' in version

@pytest.mark.asyncio
async def test_cluster_status(client):
    """Test cluster status retrieval"""
    status = await client.cluster.status.get()
    assert isinstance(status, list)

@pytest.mark.asyncio
async def test_nodes_list(client):
    """Test listing nodes"""
    nodes = await client.nodes.list()
    assert isinstance(nodes, list)
    assert len(nodes) > 0

@pytest.mark.asyncio
async def test_node_status(client):
    """Test node status"""
    nodes = await client.nodes.list()
    node_name = nodes[0]['node']
    
    status = await client.nodes(node_name).status.get()
    assert 'uptime' in status

@pytest.mark.asyncio
async def test_qemu_list(client):
    """Test listing VMs"""
    nodes = await client.nodes.list()
    node_name = nodes[0]['node']
    
    vms = await client.nodes(node_name).qemu.list()
    assert isinstance(vms, list)

@pytest.mark.asyncio
async def test_type_validation(client):
    """Test Pydantic validation"""
    from prmxctrl.models.cluster import ClusterConfigCreateParams
    from pydantic import ValidationError
    
    # Valid params
    params = ClusterConfigCreateParams(clustername="test-cluster")
    assert params.clustername == "test-cluster"
    
    # Invalid params (name too long)
    with pytest.raises(ValidationError):
        ClusterConfigCreateParams(clustername="a" * 20)
```

---

## Phase 7: Documentation (Days 14-15)

### 7.1 README.md

```markdown
# Proxmox VE Python SDK

Type-safe, auto-generated Python SDK for Proxmox VE API v7.4-2.

## Features

- ✨ **100% Type-Safe**: Full type hints with Pydantic validation
- 🔄 **Auto-Generated**: Generated from official API schema
- 🎯 **Intuitive API**: Hierarchical structure mirrors Proxmox API
- 🚀 **Async/Await**: Modern async HTTP client
- 📝 **Comprehensive**: All 600+ API endpoints included
- 🛡️ **Validated**: Input/output validation with Pydantic

## Installation

```bash
pip install prmxctrl  # Not published yet
```

## Quick Start

```python
import asyncio
from prmxctrl import ProxmoxClient

async def main():
    async with ProxmoxClient(
        host='https://proxmox.example.com:8006',
        user='root@pam',
        password='your-password',
        verify_ssl=False
    ) as client:
        # Get cluster status
        status = await client.cluster.status.get()
        print(f"Cluster: {status}")
        
        # List nodes
        nodes = await client.nodes.list()
        for node in nodes:
            print(f"Node: {node['node']}")
        
        # Get VMs on a node
        vms = await client.nodes('pve1').qemu.list()
        for vm in vms:
            print(f"VM {vm['vmid']}: {vm['name']}")
        
        # Get VM configuration
        config = await client.nodes('pve1').qemu(100).config.get()
        print(f"VM Config: {config}")
        
        # Start a VM
        await client.nodes('pve1').qemu(100).status.start()

asyncio.run(main())
```

## Authentication

### Password Authentication

```python
client = ProxmoxClient(
    host='https://proxmox.example.com:8006',
    user='root@pam',
    password='secret'
)
```

### API Token Authentication

```python
client = ProxmoxClient(
    host='https://proxmox.example.com:8006',
    user='root@pam',
    token_name='my-token',
    token_value='xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
)
```

## API Structure

The SDK mirrors Proxmox's API structure:

```python
client.cluster                    # /cluster
client.cluster.config            # /cluster/config
client.nodes                     # /nodes
client.nodes('pve1')            # /nodes/pve1
client.nodes('pve1').qemu       # /nodes/pve1/qemu
client.nodes('pve1').qemu(100)  # /nodes/pve1/qemu/100
client.nodes('pve1').qemu(100).config  # /nodes/pve1/qemu/100/config
```

## Type Safety

All parameters and responses are validated:

```python
from prmxctrl.models.nodes import NodesQemuCreateParams

# Type-safe VM creation
params = NodesQemuCreateParams(
    vmid=100,
    name="my-vm",
    memory=2048,
    cores=2,
    # IDE will autocomplete all available options!
)

vm = await client.nodes('pve1').qemu.create(params)
```

## Development

### Regenerating the SDK

```bash
# Install dependencies
pip install -r requirements-dev.txt

# Regenerate from schema
python tools/generate.py --force
```

## License

MIT License

## Disclaimer

This is an unofficial SDK and is not affiliated with or endorsed by Proxmox Server Solutions GmbH.
```
